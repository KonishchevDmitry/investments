// This file is @generated by prost-build.
/// Денежная сумма в определенной валюте.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MoneyValue {
    /// Строковый ISO-код валюты.
    #[prost(string, tag = "1")]
    pub currency: ::prost::alloc::string::String,
    /// Целая часть суммы, может быть отрицательным числом.
    #[prost(int64, tag = "2")]
    pub units: i64,
    /// Дробная часть суммы, может быть отрицательным числом.
    #[prost(int32, tag = "3")]
    pub nano: i32,
}
/// Котировка — денежная сумма без указания валюты.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Quotation {
    /// Целая часть суммы, может быть отрицательным числом.
    #[prost(int64, tag = "1")]
    pub units: i64,
    /// Дробная часть суммы, может быть отрицательным числом.
    #[prost(int32, tag = "2")]
    pub nano: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PingRequest {
    /// Время формирования запроса.
    #[prost(message, optional, tag = "1")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PingDelaySettings {
    /// Задержка (пинг) сообщений:  5000–180 000 миллисекунд. Значение по умолчанию — 120 000.
    #[prost(int32, optional, tag = "15")]
    pub ping_delay_ms: ::core::option::Option<i32>,
}
/// Проверка активности стрима.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ping {
    /// Время проверки.
    #[prost(message, optional, tag = "1")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Идентификатор соединения.
    #[prost(string, tag = "2")]
    pub stream_id: ::prost::alloc::string::String,
    /// Время формирования запроса.
    #[prost(message, optional, tag = "4")]
    pub ping_request_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Page {
    /// Максимальное число возвращаемых записей.
    #[prost(int32, tag = "1")]
    pub limit: i32,
    /// Порядковый номер страницы, начиная с 0.
    #[prost(int32, tag = "2")]
    pub page_number: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PageResponse {
    /// Максимальное число возвращаемых записей.
    #[prost(int32, tag = "1")]
    pub limit: i32,
    /// Порядковый номер страницы, начиная с 0.
    #[prost(int32, tag = "2")]
    pub page_number: i32,
    /// Общее количество записей.
    #[prost(int32, tag = "3")]
    pub total_count: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseMetadata {
    /// Идентификатор трекинга.
    #[prost(string, tag = "42")]
    pub tracking_id: ::prost::alloc::string::String,
    /// Серверное время.
    #[prost(message, optional, tag = "43")]
    pub server_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BrandData {
    /// Логотип инструмента. Имя файла для получения логотипа.
    #[prost(string, tag = "1")]
    pub logo_name: ::prost::alloc::string::String,
    ///
    /// ```text
    /// Цвет бренда.
    /// ```
    #[prost(string, tag = "2")]
    pub logo_base_color: ::prost::alloc::string::String,
    /// Цвет текста для цвета логотипа бренда.
    #[prost(string, tag = "3")]
    pub text_color: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorDetail {
    /// Код ошибки.
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Описание ошибки.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Тип инструмента.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentType {
    Unspecified = 0,
    /// Облигация.
    Bond = 1,
    /// Акция.
    Share = 2,
    /// Валюта.
    Currency = 3,
    /// Exchange-traded fund. Фонд.
    Etf = 4,
    /// Фьючерс.
    Futures = 5,
    /// Структурная нота.
    Sp = 6,
    /// Опцион.
    Option = 7,
    /// Clearing certificate.
    ClearingCertificate = 8,
    /// Индекс.
    Index = 9,
    /// Товар.
    Commodity = 10,
}
impl InstrumentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INSTRUMENT_TYPE_UNSPECIFIED",
            Self::Bond => "INSTRUMENT_TYPE_BOND",
            Self::Share => "INSTRUMENT_TYPE_SHARE",
            Self::Currency => "INSTRUMENT_TYPE_CURRENCY",
            Self::Etf => "INSTRUMENT_TYPE_ETF",
            Self::Futures => "INSTRUMENT_TYPE_FUTURES",
            Self::Sp => "INSTRUMENT_TYPE_SP",
            Self::Option => "INSTRUMENT_TYPE_OPTION",
            Self::ClearingCertificate => "INSTRUMENT_TYPE_CLEARING_CERTIFICATE",
            Self::Index => "INSTRUMENT_TYPE_INDEX",
            Self::Commodity => "INSTRUMENT_TYPE_COMMODITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTRUMENT_TYPE_BOND" => Some(Self::Bond),
            "INSTRUMENT_TYPE_SHARE" => Some(Self::Share),
            "INSTRUMENT_TYPE_CURRENCY" => Some(Self::Currency),
            "INSTRUMENT_TYPE_ETF" => Some(Self::Etf),
            "INSTRUMENT_TYPE_FUTURES" => Some(Self::Futures),
            "INSTRUMENT_TYPE_SP" => Some(Self::Sp),
            "INSTRUMENT_TYPE_OPTION" => Some(Self::Option),
            "INSTRUMENT_TYPE_CLEARING_CERTIFICATE" => Some(Self::ClearingCertificate),
            "INSTRUMENT_TYPE_INDEX" => Some(Self::Index),
            "INSTRUMENT_TYPE_COMMODITY" => Some(Self::Commodity),
            _ => None,
        }
    }
}
/// Статус запрашиваемых инструментов.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentStatus {
    /// Значение не определено.
    Unspecified = 0,
    /// По умолчанию — базовый список инструментов, которыми можно торговать через T-Invest API. Сейчас списки доступных бумаг в API и других интерфейсах совпадают — кроме внебиржевых бумаг, но в будущем списки могут различаться.
    Base = 1,
    /// Список всех инструментов.
    All = 2,
}
impl InstrumentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INSTRUMENT_STATUS_UNSPECIFIED",
            Self::Base => "INSTRUMENT_STATUS_BASE",
            Self::All => "INSTRUMENT_STATUS_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTRUMENT_STATUS_BASE" => Some(Self::Base),
            "INSTRUMENT_STATUS_ALL" => Some(Self::All),
            _ => None,
        }
    }
}
/// Режим торгов инструмента
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SecurityTradingStatus {
    /// Торговый статус не определен.
    Unspecified = 0,
    /// Недоступен для торгов.
    NotAvailableForTrading = 1,
    /// Период открытия торгов.
    OpeningPeriod = 2,
    /// Период закрытия торгов.
    ClosingPeriod = 3,
    /// Перерыв в торговле.
    BreakInTrading = 4,
    /// Нормальная торговля.
    NormalTrading = 5,
    /// Аукцион закрытия.
    ClosingAuction = 6,
    /// Аукцион крупных пакетов.
    DarkPoolAuction = 7,
    /// Дискретный аукцион.
    DiscreteAuction = 8,
    /// Аукцион открытия.
    OpeningAuctionPeriod = 9,
    /// Период торгов по цене аукциона закрытия.
    TradingAtClosingAuctionPrice = 10,
    /// Сессия назначена.
    SessionAssigned = 11,
    /// Сессия закрыта.
    SessionClose = 12,
    /// Сессия открыта.
    SessionOpen = 13,
    /// Доступна торговля в режиме внутренней ликвидности брокера.
    DealerNormalTrading = 14,
    /// Перерыв торговли в режиме внутренней ликвидности брокера.
    DealerBreakInTrading = 15,
    /// Недоступна торговля в режиме внутренней ликвидности брокера.
    DealerNotAvailableForTrading = 16,
}
impl SecurityTradingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SECURITY_TRADING_STATUS_UNSPECIFIED",
            Self::NotAvailableForTrading => {
                "SECURITY_TRADING_STATUS_NOT_AVAILABLE_FOR_TRADING"
            }
            Self::OpeningPeriod => "SECURITY_TRADING_STATUS_OPENING_PERIOD",
            Self::ClosingPeriod => "SECURITY_TRADING_STATUS_CLOSING_PERIOD",
            Self::BreakInTrading => "SECURITY_TRADING_STATUS_BREAK_IN_TRADING",
            Self::NormalTrading => "SECURITY_TRADING_STATUS_NORMAL_TRADING",
            Self::ClosingAuction => "SECURITY_TRADING_STATUS_CLOSING_AUCTION",
            Self::DarkPoolAuction => "SECURITY_TRADING_STATUS_DARK_POOL_AUCTION",
            Self::DiscreteAuction => "SECURITY_TRADING_STATUS_DISCRETE_AUCTION",
            Self::OpeningAuctionPeriod => {
                "SECURITY_TRADING_STATUS_OPENING_AUCTION_PERIOD"
            }
            Self::TradingAtClosingAuctionPrice => {
                "SECURITY_TRADING_STATUS_TRADING_AT_CLOSING_AUCTION_PRICE"
            }
            Self::SessionAssigned => "SECURITY_TRADING_STATUS_SESSION_ASSIGNED",
            Self::SessionClose => "SECURITY_TRADING_STATUS_SESSION_CLOSE",
            Self::SessionOpen => "SECURITY_TRADING_STATUS_SESSION_OPEN",
            Self::DealerNormalTrading => "SECURITY_TRADING_STATUS_DEALER_NORMAL_TRADING",
            Self::DealerBreakInTrading => {
                "SECURITY_TRADING_STATUS_DEALER_BREAK_IN_TRADING"
            }
            Self::DealerNotAvailableForTrading => {
                "SECURITY_TRADING_STATUS_DEALER_NOT_AVAILABLE_FOR_TRADING"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SECURITY_TRADING_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SECURITY_TRADING_STATUS_NOT_AVAILABLE_FOR_TRADING" => {
                Some(Self::NotAvailableForTrading)
            }
            "SECURITY_TRADING_STATUS_OPENING_PERIOD" => Some(Self::OpeningPeriod),
            "SECURITY_TRADING_STATUS_CLOSING_PERIOD" => Some(Self::ClosingPeriod),
            "SECURITY_TRADING_STATUS_BREAK_IN_TRADING" => Some(Self::BreakInTrading),
            "SECURITY_TRADING_STATUS_NORMAL_TRADING" => Some(Self::NormalTrading),
            "SECURITY_TRADING_STATUS_CLOSING_AUCTION" => Some(Self::ClosingAuction),
            "SECURITY_TRADING_STATUS_DARK_POOL_AUCTION" => Some(Self::DarkPoolAuction),
            "SECURITY_TRADING_STATUS_DISCRETE_AUCTION" => Some(Self::DiscreteAuction),
            "SECURITY_TRADING_STATUS_OPENING_AUCTION_PERIOD" => {
                Some(Self::OpeningAuctionPeriod)
            }
            "SECURITY_TRADING_STATUS_TRADING_AT_CLOSING_AUCTION_PRICE" => {
                Some(Self::TradingAtClosingAuctionPrice)
            }
            "SECURITY_TRADING_STATUS_SESSION_ASSIGNED" => Some(Self::SessionAssigned),
            "SECURITY_TRADING_STATUS_SESSION_CLOSE" => Some(Self::SessionClose),
            "SECURITY_TRADING_STATUS_SESSION_OPEN" => Some(Self::SessionOpen),
            "SECURITY_TRADING_STATUS_DEALER_NORMAL_TRADING" => {
                Some(Self::DealerNormalTrading)
            }
            "SECURITY_TRADING_STATUS_DEALER_BREAK_IN_TRADING" => {
                Some(Self::DealerBreakInTrading)
            }
            "SECURITY_TRADING_STATUS_DEALER_NOT_AVAILABLE_FOR_TRADING" => {
                Some(Self::DealerNotAvailableForTrading)
            }
            _ => None,
        }
    }
}
/// Тип цены.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PriceType {
    /// Значение не определено.
    Unspecified = 0,
    /// Цена в пунктах (только для фьючерсов и облигаций).
    Point = 1,
    /// Цена в валюте расчетов по инструменту.
    Currency = 2,
}
impl PriceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRICE_TYPE_UNSPECIFIED",
            Self::Point => "PRICE_TYPE_POINT",
            Self::Currency => "PRICE_TYPE_CURRENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRICE_TYPE_POINT" => Some(Self::Point),
            "PRICE_TYPE_CURRENCY" => Some(Self::Currency),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResultSubscriptionStatus {
    /// Статус подписки не определен.
    Unspecified = 0,
    /// Подписка успешно установлена.
    Ok = 1,
    /// Ошибка подписки
    Error = 13,
}
impl ResultSubscriptionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESULT_SUBSCRIPTION_STATUS_UNSPECIFIED",
            Self::Ok => "RESULT_SUBSCRIPTION_STATUS_OK",
            Self::Error => "RESULT_SUBSCRIPTION_STATUS_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESULT_SUBSCRIPTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "RESULT_SUBSCRIPTION_STATUS_OK" => Some(Self::Ok),
            "RESULT_SUBSCRIPTION_STATUS_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Реальная площадка исполнения расчетов.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RealExchange {
    /// Тип не определен.
    Unspecified = 0,
    /// Московская биржа.
    Moex = 1,
    /// Санкт-Петербургская биржа.
    Rts = 2,
    /// Внебиржевой инструмент.
    Otc = 3,
    /// Инструмент, торгуемый на площадке брокера.
    Dealer = 4,
}
impl RealExchange {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REAL_EXCHANGE_UNSPECIFIED",
            Self::Moex => "REAL_EXCHANGE_MOEX",
            Self::Rts => "REAL_EXCHANGE_RTS",
            Self::Otc => "REAL_EXCHANGE_OTC",
            Self::Dealer => "REAL_EXCHANGE_DEALER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REAL_EXCHANGE_UNSPECIFIED" => Some(Self::Unspecified),
            "REAL_EXCHANGE_MOEX" => Some(Self::Moex),
            "REAL_EXCHANGE_RTS" => Some(Self::Rts),
            "REAL_EXCHANGE_OTC" => Some(Self::Otc),
            "REAL_EXCHANGE_DEALER" => Some(Self::Dealer),
            _ => None,
        }
    }
}
/// Запрос расписания торгов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradingSchedulesRequest {
    /// Наименование биржи или расчетного календаря. <br/>Если не передается, возвращается информация по всем доступным торговым площадкам.
    #[prost(string, optional, tag = "1")]
    pub exchange: ::core::option::Option<::prost::alloc::string::String>,
    /// Начало периода по UTC.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
}
/// Список торговых площадок.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradingSchedulesResponse {
    /// Список торговых площадок и режимов торгов.
    #[prost(message, repeated, tag = "1")]
    pub exchanges: ::prost::alloc::vec::Vec<TradingSchedule>,
}
/// Данные по торговой площадке.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradingSchedule {
    /// Наименование торговой площадки.
    #[prost(string, tag = "1")]
    pub exchange: ::prost::alloc::string::String,
    /// Массив с торговыми и неторговыми днями.
    #[prost(message, repeated, tag = "2")]
    pub days: ::prost::alloc::vec::Vec<TradingDay>,
}
/// Информация о времени торгов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradingDay {
    /// Дата.
    #[prost(message, optional, tag = "1")]
    pub date: ::core::option::Option<::prost_types::Timestamp>,
    /// Признак торгового дня на бирже.
    #[prost(bool, tag = "2")]
    pub is_trading_day: bool,
    /// Время начала торгов по UTC.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время окончания торгов по UTC.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время начала аукциона открытия по UTC.
    #[prost(message, optional, tag = "7")]
    pub opening_auction_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время окончания аукциона закрытия по UTC.
    #[prost(message, optional, tag = "8")]
    pub closing_auction_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время начала аукциона открытия вечерней сессии по UTC.
    #[prost(message, optional, tag = "9")]
    pub evening_opening_auction_start_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
    /// Время начала вечерней сессии по UTC.
    #[prost(message, optional, tag = "10")]
    pub evening_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время окончания вечерней сессии по UTC.
    #[prost(message, optional, tag = "11")]
    pub evening_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время начала основного клиринга по UTC.
    #[prost(message, optional, tag = "12")]
    pub clearing_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время окончания основного клиринга по UTC.
    #[prost(message, optional, tag = "13")]
    pub clearing_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время начала премаркета по UTC.
    #[prost(message, optional, tag = "14")]
    pub premarket_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время окончания премаркета по UTC.
    #[prost(message, optional, tag = "15")]
    pub premarket_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время начала аукциона закрытия по UTC.
    #[prost(message, optional, tag = "16")]
    pub closing_auction_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время окончания аукциона открытия по UTC.
    #[prost(message, optional, tag = "17")]
    pub opening_auction_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Торговые интервалы.
    #[prost(message, repeated, tag = "18")]
    pub intervals: ::prost::alloc::vec::Vec<TradingInterval>,
}
/// Запрос получения инструмента по идентификатору.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentRequest {
    /// Тип идентификатора инструмента. Возможные значения — `figi`, `ticker`. [Подробнее об идентификации инструментов](./faq_identification/).
    #[prost(enumeration = "InstrumentIdType", tag = "1")]
    pub id_type: i32,
    /// Идентификатор `class_code`. Обязательный, если `id_type = ticker`.
    #[prost(string, optional, tag = "2")]
    pub class_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Идентификатор запрашиваемого инструмента.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
}
/// Запрос получения инструментов.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentsRequest {
    /// Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus).
    #[prost(enumeration = "InstrumentStatus", optional, tag = "1")]
    pub instrument_status: ::core::option::Option<i32>,
    /// Тип площадки торговли. [Возможные значения](#instrumentexchangetype).
    #[prost(enumeration = "InstrumentExchangeType", optional, tag = "2")]
    pub instrument_exchange: ::core::option::Option<i32>,
}
/// Параметры фильтрации опционов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FilterOptionsRequest {
    /// Идентификатор базового актива опциона.  Обязательный параметр.
    #[prost(string, optional, tag = "1")]
    pub basic_asset_uid: ::core::option::Option<::prost::alloc::string::String>,
    /// Идентификатор позиции базового актива опциона.
    #[prost(string, optional, tag = "2")]
    pub basic_asset_position_uid: ::core::option::Option<::prost::alloc::string::String>,
}
/// Информация об облигации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BondResponse {
    /// Информация об облигации.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Bond>,
}
/// Список облигаций.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BondsResponse {
    /// Массив облигаций.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<Bond>,
}
/// Запрос купонов по облигации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBondCouponsRequest {
    /// FIGI-идентификатор инструмента.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Начало запрашиваемого периода по UTC. Фильтрация по `coupon_date` — дата выплаты купона.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC. Фильтрация по `coupon_date` — дата выплаты купона.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Идентификатор инструмента — `figi` или `instrument_uid`.
    #[prost(string, tag = "4")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Купоны по облигации.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBondCouponsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<Coupon>,
}
/// События по облигации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBondEventsRequest {
    /// Начало запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Идентификатор инструмента — `figi` или `instrument_uid`.
    #[prost(string, tag = "4")]
    pub instrument_id: ::prost::alloc::string::String,
    /// Тип события
    #[prost(enumeration = "get_bond_events_request::EventType", tag = "5")]
    pub r#type: i32,
}
/// Nested message and enum types in `GetBondEventsRequest`.
pub mod get_bond_events_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        /// Неопределенное значение.
        Unspecified = 0,
        /// Купон.
        Cpn = 1,
        /// Опцион (оферта).
        Call = 2,
        /// Погашение.
        Mty = 3,
        /// Конвертация.
        Conv = 4,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                Self::Cpn => "EVENT_TYPE_CPN",
                Self::Call => "EVENT_TYPE_CALL",
                Self::Mty => "EVENT_TYPE_MTY",
                Self::Conv => "EVENT_TYPE_CONV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EVENT_TYPE_CPN" => Some(Self::Cpn),
                "EVENT_TYPE_CALL" => Some(Self::Call),
                "EVENT_TYPE_MTY" => Some(Self::Mty),
                "EVENT_TYPE_CONV" => Some(Self::Conv),
                _ => None,
            }
        }
    }
}
/// Объект передачи информации о событии облигации.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBondEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<get_bond_events_response::BondEvent>,
}
/// Nested message and enum types in `GetBondEventsResponse`.
pub mod get_bond_events_response {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BondEvent {
        /// Идентификатор инструмента.
        #[prost(string, tag = "2")]
        pub instrument_id: ::prost::alloc::string::String,
        /// Номер события для данного типа события.
        #[prost(int32, tag = "3")]
        pub event_number: i32,
        /// Дата события.
        #[prost(message, optional, tag = "4")]
        pub event_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Тип события.
        #[prost(enumeration = "super::get_bond_events_request::EventType", tag = "5")]
        pub event_type: i32,
        /// Полное количество бумаг, задействованных в событии.
        #[prost(message, optional, tag = "6")]
        pub event_total_vol: ::core::option::Option<super::Quotation>,
        /// Дата фиксации владельцев для участия в событии.
        #[prost(message, optional, tag = "7")]
        pub fix_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Дата определения даты или факта события.
        #[prost(message, optional, tag = "8")]
        pub rate_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Дата дефолта, если применимо.
        #[prost(message, optional, tag = "9")]
        pub default_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Дата реального исполнения обязательства.
        #[prost(message, optional, tag = "10")]
        pub real_pay_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Дата выплаты.
        #[prost(message, optional, tag = "11")]
        pub pay_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Выплата на одну облигацию.
        #[prost(message, optional, tag = "12")]
        pub pay_one_bond: ::core::option::Option<super::MoneyValue>,
        /// Выплаты на все бумаги, задействованные в событии.
        #[prost(message, optional, tag = "13")]
        pub money_flow_val: ::core::option::Option<super::MoneyValue>,
        /// Признак исполнения.
        #[prost(string, tag = "14")]
        pub execution: ::prost::alloc::string::String,
        /// Тип операции.
        #[prost(string, tag = "15")]
        pub operation_type: ::prost::alloc::string::String,
        /// Стоимость операции — ставка купона, доля номинала, цена выкупа или коэффициент конвертации.
        #[prost(message, optional, tag = "16")]
        pub value: ::core::option::Option<super::Quotation>,
        /// Примечание.
        #[prost(string, tag = "17")]
        pub note: ::prost::alloc::string::String,
        /// ID выпуска бумаг, в который произведена конвертация (для конвертаций).
        #[prost(string, tag = "18")]
        pub convert_to_fin_tool_id: ::prost::alloc::string::String,
        /// Начало купонного периода.
        #[prost(message, optional, tag = "19")]
        pub coupon_start_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Окончание купонного периода.
        #[prost(message, optional, tag = "20")]
        pub coupon_end_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Купонный период.
        #[prost(int32, tag = "21")]
        pub coupon_period: i32,
        /// Ставка купона, процентов годовых.
        #[prost(message, optional, tag = "22")]
        pub coupon_interest_rate: ::core::option::Option<super::Quotation>,
    }
}
/// Объект передачи информации о купоне облигации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Coupon {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Дата выплаты купона.
    #[prost(message, optional, tag = "2")]
    pub coupon_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Номер купона.
    #[prost(int64, tag = "3")]
    pub coupon_number: i64,
    /// Дата фиксации реестра для выплаты купона — опционально.
    #[prost(message, optional, tag = "4")]
    pub fix_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Выплата на одну облигацию.
    #[prost(message, optional, tag = "5")]
    pub pay_one_bond: ::core::option::Option<MoneyValue>,
    /// Тип купона.
    #[prost(enumeration = "CouponType", tag = "6")]
    pub coupon_type: i32,
    /// Начало купонного периода.
    #[prost(message, optional, tag = "7")]
    pub coupon_start_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание купонного периода.
    #[prost(message, optional, tag = "8")]
    pub coupon_end_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Купонный период в днях.
    #[prost(int32, tag = "9")]
    pub coupon_period: i32,
}
/// Данные по валюте.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyResponse {
    /// Информация о валюте.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Currency>,
}
/// Данные по валютам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrenciesResponse {
    /// Массив валют.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<Currency>,
}
/// Данные по фонду.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtfResponse {
    /// Информация о фонде.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Etf>,
}
/// Данные по фондам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtfsResponse {
    /// Массив фондов.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<Etf>,
}
/// Данные по фьючерсу.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FutureResponse {
    /// Информация о фьючерсу.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Future>,
}
/// Данные по фьючерсам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FuturesResponse {
    /// Массив фьючерсов.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<Future>,
}
/// Данные по опциону.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OptionResponse {
    /// Информация по опциону.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Option>,
}
/// Данные по опционам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionsResponse {
    /// Массив данных по опциону.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<Option>,
}
/// Опцион.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Option {
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор позиции.
    #[prost(string, tag = "2")]
    pub position_uid: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код.
    #[prost(string, tag = "4")]
    pub class_code: ::prost::alloc::string::String,
    /// Уникальный идентификатор позиции основного инструмента.
    #[prost(string, tag = "5")]
    pub basic_asset_position_uid: ::prost::alloc::string::String,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "21")]
    pub trading_status: i32,
    /// Реальная площадка исполнения расчетов (биржа).
    #[prost(enumeration = "RealExchange", tag = "31")]
    pub real_exchange: i32,
    /// Направление опциона.
    #[prost(enumeration = "OptionDirection", tag = "41")]
    pub direction: i32,
    /// Тип расчетов по опциону.
    #[prost(enumeration = "OptionPaymentType", tag = "42")]
    pub payment_type: i32,
    /// Стиль опциона.
    #[prost(enumeration = "OptionStyle", tag = "43")]
    pub style: i32,
    /// Способ исполнения опциона.
    #[prost(enumeration = "OptionSettlementType", tag = "44")]
    pub settlement_type: i32,
    /// Название инструмента.
    #[prost(string, tag = "101")]
    pub name: ::prost::alloc::string::String,
    /// Валюта.
    #[prost(string, tag = "111")]
    pub currency: ::prost::alloc::string::String,
    /// Валюта, в которой оценивается контракт.
    #[prost(string, tag = "112")]
    pub settlement_currency: ::prost::alloc::string::String,
    /// Тип актива.
    #[prost(string, tag = "131")]
    pub asset_type: ::prost::alloc::string::String,
    /// Основной актив.
    #[prost(string, tag = "132")]
    pub basic_asset: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "141")]
    pub exchange: ::prost::alloc::string::String,
    /// Код страны рисков.
    #[prost(string, tag = "151")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны рисков.
    #[prost(string, tag = "152")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Сектор экономики.
    #[prost(string, tag = "161")]
    pub sector: ::prost::alloc::string::String,
    /// Информация о бренде.
    #[prost(message, optional, tag = "162")]
    pub brand: ::core::option::Option<BrandData>,
    /// Количество бумаг в лоте.
    #[prost(int32, tag = "201")]
    pub lot: i32,
    /// Размер основного актива.
    #[prost(message, optional, tag = "211")]
    pub basic_asset_size: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "221")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "222")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "223")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "224")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "225")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "226")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Минимальный шаг цены.
    #[prost(message, optional, tag = "231")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Цена страйка.
    #[prost(message, optional, tag = "241")]
    pub strike_price: ::core::option::Option<MoneyValue>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "290")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "291")]
    pub dshort_client: ::core::option::Option<Quotation>,
    /// Дата истечения срока в формате UTC.
    #[prost(message, optional, tag = "301")]
    pub expiration_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата начала обращения контракта в формате UTC.
    #[prost(message, optional, tag = "311")]
    pub first_trade_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата исполнения в формате UTC.
    #[prost(message, optional, tag = "312")]
    pub last_trade_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой минутной свечи в формате UTC.
    #[prost(message, optional, tag = "321")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи в формате UTC.
    #[prost(message, optional, tag = "322")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Признак доступности для операций шорт.
    #[prost(bool, tag = "401")]
    pub short_enabled_flag: bool,
    /// Возможность покупки или продажи на ИИС.
    #[prost(bool, tag = "402")]
    pub for_iis_flag: bool,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "403")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "404")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "405")]
    pub sell_available_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "406")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "407")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "408")]
    pub blocked_tca_flag: bool,
    /// Возможность торговать инструментом через API.
    #[prost(bool, tag = "409")]
    pub api_trade_available_flag: bool,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "410")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Данные по акции.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShareResponse {
    /// Информация об акции.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Share>,
}
/// Данные по акциям.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharesResponse {
    /// Массив акций.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<Share>,
}
/// Данные по структурной ноте.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredNoteResponse {
    /// Информация о структурной ноте.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<StructuredNote>,
}
/// Данные по структурным нотам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredNotesResponse {
    /// Массив структурных нот.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<StructuredNote>,
}
/// Объект передачи информации об облигации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Bond {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "4")]
    pub isin: ::prost::alloc::string::String,
    /// Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).
    #[prost(int32, tag = "5")]
    pub lot: i32,
    /// Валюта расчетов.
    #[prost(string, tag = "6")]
    pub currency: ::prost::alloc::string::String,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "9")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "10")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "11")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "12")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Признак доступности для операций в шорт.
    #[prost(bool, tag = "13")]
    pub short_enabled_flag: bool,
    /// Название инструмента.
    #[prost(string, tag = "15")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "16")]
    pub exchange: ::prost::alloc::string::String,
    /// Количество выплат по купонам в год.
    #[prost(int32, tag = "17")]
    pub coupon_quantity_per_year: i32,
    /// Дата погашения облигации по UTC.
    #[prost(message, optional, tag = "18")]
    pub maturity_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Номинал облигации.
    #[prost(message, optional, tag = "19")]
    pub nominal: ::core::option::Option<MoneyValue>,
    /// Первоначальный номинал облигации.
    #[prost(message, optional, tag = "20")]
    pub initial_nominal: ::core::option::Option<MoneyValue>,
    /// Дата выпуска облигации по UTC.
    #[prost(message, optional, tag = "21")]
    pub state_reg_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата размещения по UTC.
    #[prost(message, optional, tag = "22")]
    pub placement_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Цена размещения.
    #[prost(message, optional, tag = "23")]
    pub placement_price: ::core::option::Option<MoneyValue>,
    /// Значение НКД (накопленного купонного дохода) на дату.
    #[prost(message, optional, tag = "24")]
    pub aci_value: ::core::option::Option<MoneyValue>,
    /// Код страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "25")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "26")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Сектор экономики.
    #[prost(string, tag = "27")]
    pub sector: ::prost::alloc::string::String,
    /// Форма выпуска. Возможные значения: <br/>**documentary** — документарная; <br/>**non_documentary** — бездокументарная.
    #[prost(string, tag = "28")]
    pub issue_kind: ::prost::alloc::string::String,
    /// Размер выпуска.
    #[prost(int64, tag = "29")]
    pub issue_size: i64,
    /// Плановый размер выпуска.
    #[prost(int64, tag = "30")]
    pub issue_size_plan: i64,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "31")]
    pub trading_status: i32,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "32")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "33")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "34")]
    pub sell_available_flag: bool,
    /// Признак облигации с плавающим купоном.
    #[prost(bool, tag = "35")]
    pub floating_coupon_flag: bool,
    /// Признак бессрочной облигации.
    #[prost(bool, tag = "36")]
    pub perpetual_flag: bool,
    /// Признак облигации с амортизацией долга.
    #[prost(bool, tag = "37")]
    pub amortization_flag: bool,
    /// Шаг цены.
    #[prost(message, optional, tag = "38")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Параметр указывает на возможность торговать инструментом через API.
    #[prost(bool, tag = "39")]
    pub api_trade_available_flag: bool,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "40")]
    pub uid: ::prost::alloc::string::String,
    /// Реальная площадка исполнения расчетов. (биржа)
    #[prost(enumeration = "RealExchange", tag = "41")]
    pub real_exchange: i32,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "42")]
    pub position_uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "43")]
    pub asset_uid: ::prost::alloc::string::String,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "44")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "51")]
    pub for_iis_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "52")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "53")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "54")]
    pub blocked_tca_flag: bool,
    /// Признак субординированной облигации.
    #[prost(bool, tag = "55")]
    pub subordinated_flag: bool,
    /// Флаг достаточной ликвидности.
    #[prost(bool, tag = "56")]
    pub liquidity_flag: bool,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "61")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "62")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Уровень риска.
    #[prost(enumeration = "RiskLevel", tag = "63")]
    pub risk_level: i32,
    /// Информация о бренде.
    #[prost(message, optional, tag = "64")]
    pub brand: ::core::option::Option<BrandData>,
    /// Тип облигации.
    #[prost(enumeration = "BondType", tag = "65")]
    pub bond_type: i32,
    /// Дата погашения облигации.
    #[prost(message, optional, tag = "69")]
    pub call_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "90")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "91")]
    pub dshort_client: ::core::option::Option<Quotation>,
}
/// Объект передачи информации о валюте.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Currency {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "4")]
    pub isin: ::prost::alloc::string::String,
    /// Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).
    #[prost(int32, tag = "5")]
    pub lot: i32,
    /// Валюта расчетов.
    #[prost(string, tag = "6")]
    pub currency: ::prost::alloc::string::String,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "9")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "10")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "11")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "12")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Признак доступности для операций в шорт.
    #[prost(bool, tag = "13")]
    pub short_enabled_flag: bool,
    /// Название инструмента.
    #[prost(string, tag = "15")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "16")]
    pub exchange: ::prost::alloc::string::String,
    /// Номинал.
    #[prost(message, optional, tag = "17")]
    pub nominal: ::core::option::Option<MoneyValue>,
    /// Код страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "18")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "19")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "20")]
    pub trading_status: i32,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "21")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "22")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "23")]
    pub sell_available_flag: bool,
    /// Строковый ISO-код валюты.
    #[prost(string, tag = "24")]
    pub iso_currency_name: ::prost::alloc::string::String,
    /// Шаг цены.
    #[prost(message, optional, tag = "25")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Параметр указывает на возможность торговать инструментом через API.
    #[prost(bool, tag = "26")]
    pub api_trade_available_flag: bool,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "27")]
    pub uid: ::prost::alloc::string::String,
    /// Реальная площадка исполнения расчетов (биржа).
    #[prost(enumeration = "RealExchange", tag = "28")]
    pub real_exchange: i32,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "29")]
    pub position_uid: ::prost::alloc::string::String,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "30")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "41")]
    pub for_iis_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "52")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "53")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "54")]
    pub blocked_tca_flag: bool,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "56")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "57")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Информация о бренде.
    #[prost(message, optional, tag = "60")]
    pub brand: ::core::option::Option<BrandData>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "90")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "91")]
    pub dshort_client: ::core::option::Option<Quotation>,
}
/// Объект передачи информации об инвестиционном фонде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Etf {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "4")]
    pub isin: ::prost::alloc::string::String,
    /// Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).
    #[prost(int32, tag = "5")]
    pub lot: i32,
    /// Валюта расчетов.
    #[prost(string, tag = "6")]
    pub currency: ::prost::alloc::string::String,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "9")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "10")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "11")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "12")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Признак доступности для операций в шорт.
    #[prost(bool, tag = "13")]
    pub short_enabled_flag: bool,
    /// Название инструмента.
    #[prost(string, tag = "15")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "16")]
    pub exchange: ::prost::alloc::string::String,
    /// Размер фиксированной комиссии фонда.
    #[prost(message, optional, tag = "17")]
    pub fixed_commission: ::core::option::Option<Quotation>,
    /// Возможные значения: <br/>**equity** — акции;<br/>**fixed_income** — облигации;<br/>**mixed_allocation** — смешанный;<br/>**money_market** — денежный рынок;<br/>**real_estate** — недвижимость;<br/>**commodity** — товары;<br/>**specialty** — специальный;<br/>**private_equity** — private equity;<br/>**alternative_investment** — альтернативные инвестиции.
    #[prost(string, tag = "18")]
    pub focus_type: ::prost::alloc::string::String,
    /// Дата выпуска по UTC.
    #[prost(message, optional, tag = "19")]
    pub released_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Количество паев фонда в обращении.
    #[prost(message, optional, tag = "20")]
    pub num_shares: ::core::option::Option<Quotation>,
    /// Код страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "21")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "22")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Сектор экономики.
    #[prost(string, tag = "23")]
    pub sector: ::prost::alloc::string::String,
    /// Частота ребалансировки.
    #[prost(string, tag = "24")]
    pub rebalancing_freq: ::prost::alloc::string::String,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "25")]
    pub trading_status: i32,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "26")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "27")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "28")]
    pub sell_available_flag: bool,
    /// Шаг цены.
    #[prost(message, optional, tag = "29")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Параметр указывает на возможность торговать инструментом через API.
    #[prost(bool, tag = "30")]
    pub api_trade_available_flag: bool,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "31")]
    pub uid: ::prost::alloc::string::String,
    /// Реальная площадка исполнения расчетов (биржа).
    #[prost(enumeration = "RealExchange", tag = "32")]
    pub real_exchange: i32,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "33")]
    pub position_uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "34")]
    pub asset_uid: ::prost::alloc::string::String,
    /// Тип площадки торговли.
    #[prost(enumeration = "InstrumentExchangeType", tag = "35")]
    pub instrument_exchange: i32,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "36")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "41")]
    pub for_iis_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "42")]
    pub for_qual_investor_flag: bool,
    /// ФлагФлаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "43")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "44")]
    pub blocked_tca_flag: bool,
    /// Флаг достаточной ликвидности.
    #[prost(bool, tag = "45")]
    pub liquidity_flag: bool,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "56")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "57")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Информация о бренде.
    #[prost(message, optional, tag = "60")]
    pub brand: ::core::option::Option<BrandData>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "90")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "91")]
    pub dshort_client: ::core::option::Option<Quotation>,
}
/// Объект передачи информации о фьючерсе.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Future {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).
    #[prost(int32, tag = "4")]
    pub lot: i32,
    /// Валюта расчетов.
    #[prost(string, tag = "5")]
    pub currency: ::prost::alloc::string::String,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "8")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "9")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "10")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "11")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Признак доступности для операций шорт.
    #[prost(bool, tag = "12")]
    pub short_enabled_flag: bool,
    /// Название инструмента.
    #[prost(string, tag = "13")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "14")]
    pub exchange: ::prost::alloc::string::String,
    /// Дата начала обращения контракта по UTC.
    #[prost(message, optional, tag = "15")]
    pub first_trade_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата по UTC, до которой возможно проведение операций с фьючерсом.
    #[prost(message, optional, tag = "16")]
    pub last_trade_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Тип фьючерса. Возможные значения: <br/>**physical_delivery** — физические поставки; <br/>**cash_settlement** — денежный эквивалент.
    #[prost(string, tag = "17")]
    pub futures_type: ::prost::alloc::string::String,
    /// Тип актива. Возможные значения: <br/>**commodity** — товар; <br/>**currency** — валюта; <br/>**security** — ценная бумага; <br/>**index** — индекс.
    #[prost(string, tag = "18")]
    pub asset_type: ::prost::alloc::string::String,
    /// Основной актив.
    #[prost(string, tag = "19")]
    pub basic_asset: ::prost::alloc::string::String,
    /// Размер основного актива.
    #[prost(message, optional, tag = "20")]
    pub basic_asset_size: ::core::option::Option<Quotation>,
    /// Код страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "21")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "22")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Сектор экономики.
    #[prost(string, tag = "23")]
    pub sector: ::prost::alloc::string::String,
    /// Дата истечения срока в часов поясе UTC.
    #[prost(message, optional, tag = "24")]
    pub expiration_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "25")]
    pub trading_status: i32,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "26")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "27")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "28")]
    pub sell_available_flag: bool,
    /// Шаг цены.
    #[prost(message, optional, tag = "29")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Параметр указывает на возможность торговать инструментом через API.
    #[prost(bool, tag = "30")]
    pub api_trade_available_flag: bool,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "31")]
    pub uid: ::prost::alloc::string::String,
    /// Реальная площадка исполнения расчетов (биржа).
    #[prost(enumeration = "RealExchange", tag = "32")]
    pub real_exchange: i32,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "33")]
    pub position_uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор позиции основного инструмента.
    #[prost(string, tag = "34")]
    pub basic_asset_position_uid: ::prost::alloc::string::String,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "35")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "41")]
    pub for_iis_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "42")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "43")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "44")]
    pub blocked_tca_flag: bool,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "56")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "57")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Гарантийное обеспечение при покупке.
    #[prost(message, optional, tag = "61")]
    pub initial_margin_on_buy: ::core::option::Option<MoneyValue>,
    /// Гарантийное обеспечение при продаже.
    #[prost(message, optional, tag = "62")]
    pub initial_margin_on_sell: ::core::option::Option<MoneyValue>,
    /// Стоимость шага цены.
    #[prost(message, optional, tag = "63")]
    pub min_price_increment_amount: ::core::option::Option<Quotation>,
    /// Информация о бренде.
    #[prost(message, optional, tag = "64")]
    pub brand: ::core::option::Option<BrandData>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "90")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "91")]
    pub dshort_client: ::core::option::Option<Quotation>,
}
/// Объект передачи информации об акции.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Share {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "4")]
    pub isin: ::prost::alloc::string::String,
    /// Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot)
    #[prost(int32, tag = "5")]
    pub lot: i32,
    /// Валюта расчетов.
    #[prost(string, tag = "6")]
    pub currency: ::prost::alloc::string::String,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "9")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "10")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "11")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "12")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Признак доступности для операций в шорт.
    #[prost(bool, tag = "13")]
    pub short_enabled_flag: bool,
    /// Название инструмента.
    #[prost(string, tag = "15")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "16")]
    pub exchange: ::prost::alloc::string::String,
    /// Дата IPO акции по UTC.
    #[prost(message, optional, tag = "17")]
    pub ipo_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Размер выпуска.
    #[prost(int64, tag = "18")]
    pub issue_size: i64,
    /// Код страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "19")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "20")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Сектор экономики.
    #[prost(string, tag = "21")]
    pub sector: ::prost::alloc::string::String,
    /// Плановый размер выпуска.
    #[prost(int64, tag = "22")]
    pub issue_size_plan: i64,
    /// Номинал.
    #[prost(message, optional, tag = "23")]
    pub nominal: ::core::option::Option<MoneyValue>,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "25")]
    pub trading_status: i32,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "26")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "27")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "28")]
    pub sell_available_flag: bool,
    /// Признак наличия дивидендной доходности.
    #[prost(bool, tag = "29")]
    pub div_yield_flag: bool,
    /// Тип акции. Возможные значения — `[ShareType](./instruments#sharetype)`.
    #[prost(enumeration = "ShareType", tag = "30")]
    pub share_type: i32,
    /// Шаг цены.
    #[prost(message, optional, tag = "31")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Возможность торговать инструментом через API.
    #[prost(bool, tag = "32")]
    pub api_trade_available_flag: bool,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "33")]
    pub uid: ::prost::alloc::string::String,
    /// Реальная площадка исполнения расчетов (биржа).
    #[prost(enumeration = "RealExchange", tag = "34")]
    pub real_exchange: i32,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "35")]
    pub position_uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "36")]
    pub asset_uid: ::prost::alloc::string::String,
    /// Тип площадки торговли.
    #[prost(enumeration = "InstrumentExchangeType", tag = "37")]
    pub instrument_exchange: i32,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "38")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "46")]
    pub for_iis_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "47")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "48")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "49")]
    pub blocked_tca_flag: bool,
    /// Флаг достаточной ликвидности.
    #[prost(bool, tag = "50")]
    pub liquidity_flag: bool,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "56")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "57")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Информация о бренде.
    #[prost(message, optional, tag = "60")]
    pub brand: ::core::option::Option<BrandData>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "90")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "91")]
    pub dshort_client: ::core::option::Option<Quotation>,
}
/// Объект передачи информации о структурной ноте.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredNote {
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "2")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "4")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "5")]
    pub isin: ::prost::alloc::string::String,
    /// Название инструмента.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "7")]
    pub asset_uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор позиции.
    #[prost(string, tag = "8")]
    pub position_uid: ::prost::alloc::string::String,
    /// Шаг цены.
    #[prost(message, optional, tag = "9")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Лотность инструмента.
    #[prost(int32, tag = "10")]
    pub lot: i32,
    /// Номинал.
    #[prost(message, optional, tag = "11")]
    pub nominal: ::core::option::Option<MoneyValue>,
    /// Валюта расчетов.
    #[prost(string, tag = "12")]
    pub currency: ::prost::alloc::string::String,
    /// Дата погашения облигации в формате UTC.
    #[prost(message, optional, tag = "13")]
    pub maturity_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата размещения в формате UTC.
    #[prost(message, optional, tag = "14")]
    pub placement_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Форма выпуска.
    #[prost(string, tag = "15")]
    pub issue_kind: ::prost::alloc::string::String,
    /// Размер выпуска.
    #[prost(int32, tag = "16")]
    pub issue_size: i32,
    /// Плановый размер выпуска.
    #[prost(int32, tag = "17")]
    pub issue_size_plan: i32,
    /// Ставка риска клиента по инструменту лонг.
    #[prost(message, optional, tag = "18")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска клиента по инструменту шорт.
    #[prost(message, optional, tag = "19")]
    pub dshort_client: ::core::option::Option<Quotation>,
    /// Признак доступности для операций в шорт.
    #[prost(bool, tag = "20")]
    pub short_enabled_flag: bool,
    /// Торговая площадка (секция биржи).
    #[prost(string, tag = "21")]
    pub exchange: ::prost::alloc::string::String,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "22")]
    pub trading_status: i32,
    /// Признак доступности торгов по бумаге через API.
    #[prost(bool, tag = "23")]
    pub api_trade_available_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "24")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "25")]
    pub sell_available_flag: bool,
    /// Признак доступности выставления лимитной заявки по инструменту.
    #[prost(bool, tag = "26")]
    pub limit_order_available_flag: bool,
    /// Признак доступности выставления рыночной заявки по инструменту.
    #[prost(bool, tag = "27")]
    pub market_order_available_flag: bool,
    /// Признак доступности выставления bestprice заявки по инструменту.
    #[prost(bool, tag = "28")]
    pub bestprice_order_available_flag: bool,
    /// Флаг отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "29")]
    pub weekend_flag: bool,
    /// Флаг достаточной ликвидности.
    #[prost(bool, tag = "30")]
    pub liquidity_flag: bool,
    /// Возможность покупки/продажи на ИИС.
    #[prost(bool, tag = "31")]
    pub for_iis_flag: bool,
    /// Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "32")]
    pub for_qual_investor_flag: bool,
    /// Признак ФИ, включенного в ломбардный список.
    #[prost(bool, tag = "33")]
    pub pawnshop_list_flag: bool,
    /// Реальная площадка исполнения расчётов.
    #[prost(enumeration = "RealExchange", tag = "34")]
    pub real_exchange: i32,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "35")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "36")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Название заемщика.
    #[prost(string, tag = "37")]
    pub borrow_name: ::prost::alloc::string::String,
    /// Тип структурной ноты.
    #[prost(string, tag = "38")]
    pub r#type: ::prost::alloc::string::String,
    /// Стратегия портфеля.
    #[prost(enumeration = "structured_note::LogicPortfolio", tag = "39")]
    pub logic_portfolio: i32,
    /// Тип базового актива.
    #[prost(enumeration = "AssetType", tag = "40")]
    pub asset_type: i32,
    /// Базовые активы, входящие в ноту.
    #[prost(message, repeated, tag = "41")]
    pub basic_assets: ::prost::alloc::vec::Vec<structured_note::BasicAsset>,
    /// Барьер сохранности (в процентах).
    #[prost(message, optional, tag = "42")]
    pub safety_barrier: ::core::option::Option<Quotation>,
    /// Базис расчета НКД.
    #[prost(string, tag = "43")]
    pub coupon_period_base: ::prost::alloc::string::String,
    /// Принцип наблюдений.
    #[prost(enumeration = "structured_note::ObservationPrinciple", tag = "44")]
    pub observation_principle: i32,
    /// Частота наблюдений.
    #[prost(string, tag = "45")]
    pub observation_frequency: ::prost::alloc::string::String,
    /// Дата фиксации цен базовых активов.
    #[prost(message, optional, tag = "46")]
    pub initial_price_fixing_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Доходность по ноте в годовом выражении.
    #[prost(message, repeated, tag = "47")]
    pub r#yield: ::prost::alloc::vec::Vec<structured_note::Yield>,
    /// Признак сохранения купонов.
    #[prost(bool, tag = "48")]
    pub coupon_saving_flag: bool,
    /// Сектор экономики.
    #[prost(string, tag = "49")]
    pub sector: ::prost::alloc::string::String,
    /// Код страны рисков.
    #[prost(string, tag = "50")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны рисков.
    #[prost(string, tag = "51")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Имя файла логотипа эмитента.
    #[prost(string, tag = "52")]
    pub logo_name: ::prost::alloc::string::String,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать покупки по бумаге.
    #[prost(string, repeated, tag = "53")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `StructuredNote`.
pub mod structured_note {
    /// Базовый актив.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BasicAsset {
        /// Уникальный идентификатор базового актива.
        #[prost(string, tag = "1")]
        pub uid: ::prost::alloc::string::String,
        /// Тип базового актива.
        #[prost(enumeration = "super::AssetType", tag = "2")]
        pub r#type: i32,
        /// Начальная цена базового актива.
        #[prost(message, optional, tag = "3")]
        pub initial_price: ::core::option::Option<super::Quotation>,
    }
    /// Доходность.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Yield {
        /// Тип доходности.
        #[prost(enumeration = "YieldType", tag = "1")]
        pub r#type: i32,
        /// Значение доходности.
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::Quotation>,
    }
    /// Стратегия портфеля.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogicPortfolio {
        /// Стратегия портфеля не определена.
        Unspecified = 0,
        /// Волатильность.
        Volatility = 1,
        /// Корреляция.
        Correlation = 2,
    }
    impl LogicPortfolio {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOGIC_PORTFOLIO_UNSPECIFIED",
                Self::Volatility => "LOGIC_PORTFOLIO_VOLATILITY",
                Self::Correlation => "LOGIC_PORTFOLIO_CORRELATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOGIC_PORTFOLIO_UNSPECIFIED" => Some(Self::Unspecified),
                "LOGIC_PORTFOLIO_VOLATILITY" => Some(Self::Volatility),
                "LOGIC_PORTFOLIO_CORRELATION" => Some(Self::Correlation),
                _ => None,
            }
        }
    }
    /// Принцип наблюдений.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ObservationPrinciple {
        /// Принцип наблюдений не определен.
        Unspecified = 0,
        /// По худшему базовому активу.
        WorstBasicAsset = 1,
        /// По лучшему базовому активу.
        BestBasicAsset = 2,
        /// Среднее значение по базовым активам.
        AverageOfBasicAssets = 3,
        /// Динамика актива (только если у ноты один базовый актив).
        SingleBasicAssetPerformance = 4,
    }
    impl ObservationPrinciple {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OBSERVATION_PRINCIPLE_UNSPECIFIED",
                Self::WorstBasicAsset => "OBSERVATION_PRINCIPLE_WORST_BASIC_ASSET",
                Self::BestBasicAsset => "OBSERVATION_PRINCIPLE_BEST_BASIC_ASSET",
                Self::AverageOfBasicAssets => {
                    "OBSERVATION_PRINCIPLE_AVERAGE_OF_BASIC_ASSETS"
                }
                Self::SingleBasicAssetPerformance => {
                    "OBSERVATION_PRINCIPLE_SINGLE_BASIC_ASSET_PERFORMANCE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OBSERVATION_PRINCIPLE_UNSPECIFIED" => Some(Self::Unspecified),
                "OBSERVATION_PRINCIPLE_WORST_BASIC_ASSET" => Some(Self::WorstBasicAsset),
                "OBSERVATION_PRINCIPLE_BEST_BASIC_ASSET" => Some(Self::BestBasicAsset),
                "OBSERVATION_PRINCIPLE_AVERAGE_OF_BASIC_ASSETS" => {
                    Some(Self::AverageOfBasicAssets)
                }
                "OBSERVATION_PRINCIPLE_SINGLE_BASIC_ASSET_PERFORMANCE" => {
                    Some(Self::SingleBasicAssetPerformance)
                }
                _ => None,
            }
        }
    }
    /// Тип доходности.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum YieldType {
        /// Тип доходности не определен.
        Unspecified = 0,
        /// Гарантированный купон.
        GuarantedCoupon = 1,
        /// Условный купон.
        ConditionalCoupon = 2,
        /// Участие в росте.
        Participation = 3,
    }
    impl YieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "YIELD_TYPE_UNSPECIFIED",
                Self::GuarantedCoupon => "YIELD_TYPE_GUARANTED_COUPON",
                Self::ConditionalCoupon => "YIELD_TYPE_CONDITIONAL_COUPON",
                Self::Participation => "YIELD_TYPE_PARTICIPATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "YIELD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "YIELD_TYPE_GUARANTED_COUPON" => Some(Self::GuarantedCoupon),
                "YIELD_TYPE_CONDITIONAL_COUPON" => Some(Self::ConditionalCoupon),
                "YIELD_TYPE_PARTICIPATION" => Some(Self::Participation),
                _ => None,
            }
        }
    }
}
/// Запрос НКД по облигации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAccruedInterestsRequest {
    /// FIGI-идентификатор инструмента.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Начало запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Идентификатор инструмента — `figi` или `instrument_uid`.
    #[prost(string, tag = "4")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// НКД облигации.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccruedInterestsResponse {
    /// Массив операций начисления купонов.
    #[prost(message, repeated, tag = "1")]
    pub accrued_interests: ::prost::alloc::vec::Vec<AccruedInterest>,
}
/// Операция начисления купонов.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccruedInterest {
    /// Дата и время выплаты по UTC.
    #[prost(message, optional, tag = "1")]
    pub date: ::core::option::Option<::prost_types::Timestamp>,
    /// Величина выплаты.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Quotation>,
    /// Величина выплаты в процентах от номинала.
    #[prost(message, optional, tag = "3")]
    pub value_percent: ::core::option::Option<Quotation>,
    /// Номинал облигации.
    #[prost(message, optional, tag = "4")]
    pub nominal: ::core::option::Option<Quotation>,
}
/// Запрос информации о фьючерсе
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFuturesMarginRequest {
    /// Идентификатор инструмента.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Идентификатор инструмента — `figi` или `instrument_uid`.
    #[prost(string, tag = "4")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Данные по фьючерсу
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFuturesMarginResponse {
    /// Гарантийное обеспечение при покупке.
    #[prost(message, optional, tag = "1")]
    pub initial_margin_on_buy: ::core::option::Option<MoneyValue>,
    /// Гарантийное обеспечение при продаже.
    #[prost(message, optional, tag = "2")]
    pub initial_margin_on_sell: ::core::option::Option<MoneyValue>,
    /// Шаг цены.
    #[prost(message, optional, tag = "3")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Стоимость шага цены.
    #[prost(message, optional, tag = "4")]
    pub min_price_increment_amount: ::core::option::Option<Quotation>,
}
/// Данные по инструменту.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentResponse {
    /// Основная информация об инструменте.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<Instrument>,
}
/// Объект передачи основной информации об инструменте.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Instrument {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код инструмента.
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "4")]
    pub isin: ::prost::alloc::string::String,
    /// Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру `lot`. [Подробнее](./glossary#lot).
    #[prost(int32, tag = "5")]
    pub lot: i32,
    /// Валюта расчетов.
    #[prost(string, tag = "6")]
    pub currency: ::prost::alloc::string::String,
    /// Коэффициент ставки риска длинной позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub klong: ::core::option::Option<Quotation>,
    /// Коэффициент ставки риска короткой позиции по клиенту. 2 – клиент со стандартным уровнем риска (КСУР); 1 – клиент с повышенным уровнем риска (КПУР).
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub kshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "9")]
    pub dlong: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КСУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "10")]
    pub dshort: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР лонг. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "11")]
    pub dlong_min: ::core::option::Option<Quotation>,
    /// Ставка риска начальной маржи для КПУР шорт. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "12")]
    pub dshort_min: ::core::option::Option<Quotation>,
    /// Признак доступности для операций в шорт.
    #[prost(bool, tag = "13")]
    pub short_enabled_flag: bool,
    /// Название инструмента.
    #[prost(string, tag = "14")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "15")]
    pub exchange: ::prost::alloc::string::String,
    /// Код страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "16")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска — то есть страны, в которой компания ведет основной бизнес.
    #[prost(string, tag = "17")]
    pub country_of_risk_name: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(string, tag = "18")]
    pub instrument_type: ::prost::alloc::string::String,
    /// Текущий режим торгов инструмента.
    #[prost(enumeration = "SecurityTradingStatus", tag = "19")]
    pub trading_status: i32,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "20")]
    pub otc_flag: bool,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "21")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "22")]
    pub sell_available_flag: bool,
    /// Шаг цены.
    #[prost(message, optional, tag = "23")]
    pub min_price_increment: ::core::option::Option<Quotation>,
    /// Параметр указывает на возможность торговать инструментом через API.
    #[prost(bool, tag = "24")]
    pub api_trade_available_flag: bool,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "25")]
    pub uid: ::prost::alloc::string::String,
    /// Реальная площадка исполнения расчетов (биржа).
    #[prost(enumeration = "RealExchange", tag = "26")]
    pub real_exchange: i32,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "27")]
    pub position_uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "28")]
    pub asset_uid: ::prost::alloc::string::String,
    /// Тесты, которые необходимо пройти клиенту, чтобы совершать сделки по инструменту.
    #[prost(string, repeated, tag = "29")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "36")]
    pub for_iis_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "37")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "38")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "39")]
    pub blocked_tca_flag: bool,
    /// Тип инструмента.
    #[prost(enumeration = "InstrumentType", tag = "40")]
    pub instrument_kind: i32,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "56")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "57")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Информация о бренде.
    #[prost(message, optional, tag = "60")]
    pub brand: ::core::option::Option<BrandData>,
    /// Ставка риска в лонг с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "490")]
    pub dlong_client: ::core::option::Option<Quotation>,
    /// Ставка риска в шорт с учетом текущего уровня риска портфеля клиента. [Подробнее про ставки риска](<https://www.tbank.ru/invest/help/brokerage/account/margin/about/#q5>).
    #[prost(message, optional, tag = "491")]
    pub dshort_client: ::core::option::Option<Quotation>,
}
/// Запрос дивидендов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDividendsRequest {
    /// FIGI-идентификатор инструмента.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Начало запрашиваемого периода по UTC. Фильтрация происходит по параметру `record_date` — дата фиксации реестра.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC. Фильтрация происходит по параметру `record_date` — дата фиксации реестра.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Идентификатор инструмента — `figi` или `instrument_uid`.
    #[prost(string, tag = "4")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Дивиденды.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDividendsResponse {
    #[prost(message, repeated, tag = "1")]
    pub dividends: ::prost::alloc::vec::Vec<Dividend>,
}
/// Информация о выплате.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Dividend {
    /// Величина дивиденда на 1 ценную бумагу (включая валюту).
    #[prost(message, optional, tag = "1")]
    pub dividend_net: ::core::option::Option<MoneyValue>,
    /// Дата фактических выплат по UTC.
    #[prost(message, optional, tag = "2")]
    pub payment_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата объявления дивидендов по UTC.
    #[prost(message, optional, tag = "3")]
    pub declared_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Последний день (включительно) покупки для получения выплаты по UTC.
    #[prost(message, optional, tag = "4")]
    pub last_buy_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Тип выплаты. Возможные значения: `Regular Cash` – регулярные выплаты, `Cancelled` – выплата отменена, `Daily Accrual` – ежедневное начисление, `Return of Capital` – возврат капитала, прочие типы выплат.
    #[prost(string, tag = "5")]
    pub dividend_type: ::prost::alloc::string::String,
    /// Дата фиксации реестра по UTC.
    #[prost(message, optional, tag = "6")]
    pub record_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Регулярность выплаты. Возможные значения: `Annual` – ежегодная, `Semi-Anl` – каждые полгода, прочие типы выплат.
    #[prost(string, tag = "7")]
    pub regularity: ::prost::alloc::string::String,
    /// Цена закрытия инструмента на момент `ex_dividend_date`.
    #[prost(message, optional, tag = "8")]
    pub close_price: ::core::option::Option<MoneyValue>,
    /// Величина доходности.
    #[prost(message, optional, tag = "9")]
    pub yield_value: ::core::option::Option<Quotation>,
    /// Дата и время создания записи по UTC.
    #[prost(message, optional, tag = "10")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Запрос актива по идентификатору.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetRequest {
    /// UID-идентификатор актива.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Данные по активу.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetResponse {
    /// Актив.
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<AssetFull>,
}
/// Запрос списка активов.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetsRequest {
    #[prost(enumeration = "InstrumentType", optional, tag = "1")]
    pub instrument_type: ::core::option::Option<i32>,
    /// Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus).
    #[prost(enumeration = "InstrumentStatus", optional, tag = "2")]
    pub instrument_status: ::core::option::Option<i32>,
}
/// Список активов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetsResponse {
    /// Активы.
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetFull {
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// Тип актива.
    #[prost(enumeration = "AssetType", tag = "2")]
    pub r#type: i32,
    /// Наименование актива.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Короткое наименование актива.
    #[prost(string, tag = "4")]
    pub name_brief: ::prost::alloc::string::String,
    /// Описание актива.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Дата и время удаления актива.
    #[prost(message, optional, tag = "6")]
    pub deleted_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Тестирование клиентов.
    #[prost(string, repeated, tag = "7")]
    pub required_tests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Номер государственной регистрации.
    #[prost(string, tag = "10")]
    pub gos_reg_code: ::prost::alloc::string::String,
    /// Код CFI.
    #[prost(string, tag = "11")]
    pub cfi: ::prost::alloc::string::String,
    /// Код НРД инструмента.
    #[prost(string, tag = "12")]
    pub code_nsd: ::prost::alloc::string::String,
    /// Статус актива.
    #[prost(string, tag = "13")]
    pub status: ::prost::alloc::string::String,
    /// Бренд.
    #[prost(message, optional, tag = "14")]
    pub brand: ::core::option::Option<Brand>,
    /// Дата и время последнего обновления записи.
    #[prost(message, optional, tag = "15")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Код типа ц.б. по классификации Банка России.
    #[prost(string, tag = "16")]
    pub br_code: ::prost::alloc::string::String,
    /// Наименование кода типа ц.б. по классификации Банка России.
    #[prost(string, tag = "17")]
    pub br_code_name: ::prost::alloc::string::String,
    /// Массив идентификаторов инструментов.
    #[prost(message, repeated, tag = "18")]
    pub instruments: ::prost::alloc::vec::Vec<AssetInstrument>,
    #[prost(oneof = "asset_full::Ext", tags = "8, 9")]
    pub ext: ::core::option::Option<asset_full::Ext>,
}
/// Nested message and enum types in `AssetFull`.
pub mod asset_full {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Ext {
        /// Валюта. Обязательно и заполняется только для `type = ASSET_TYPE_CURRENCY`.
        #[prost(message, tag = "8")]
        Currency(super::AssetCurrency),
        /// Ценная бумага. Обязательно и заполняется только для `type = ASSET_TYPE_SECURITY`.
        #[prost(message, tag = "9")]
        Security(super::AssetSecurity),
    }
}
/// Информация об активе.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    /// Уникальный идентификатор актива.
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// Тип актива.
    #[prost(enumeration = "AssetType", tag = "2")]
    pub r#type: i32,
    /// Наименование актива.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Массив идентификаторов инструментов.
    #[prost(message, repeated, tag = "4")]
    pub instruments: ::prost::alloc::vec::Vec<AssetInstrument>,
}
/// Валюта.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetCurrency {
    /// ISO-код валюты.
    #[prost(string, tag = "1")]
    pub base_currency: ::prost::alloc::string::String,
}
/// Ценная бумага.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetSecurity {
    /// ISIN-идентификатор ценной бумаги.
    #[prost(string, tag = "1")]
    pub isin: ::prost::alloc::string::String,
    /// Тип ценной бумаги.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(enumeration = "InstrumentType", tag = "10")]
    pub instrument_kind: i32,
    #[prost(oneof = "asset_security::Ext", tags = "3, 4, 5, 6, 7")]
    pub ext: ::core::option::Option<asset_security::Ext>,
}
/// Nested message and enum types in `AssetSecurity`.
pub mod asset_security {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Ext {
        /// Акция. Заполняется только для акций — тип актива `asset.type = ASSET_TYPE_SECURITY` и `security.type = share`.
        #[prost(message, tag = "3")]
        Share(super::AssetShare),
        /// Облигация. Заполняется только для облигаций — тип актива `asset.type = ASSET_TYPE_SECURITY` и `security.type = bond`.
        #[prost(message, tag = "4")]
        Bond(super::AssetBond),
        /// Структурная нота. Заполняется только для структурных продуктов — тип актива `asset.type = ASSET_TYPE_SECURITY` и `security.type = sp`.
        #[prost(message, tag = "5")]
        Sp(super::AssetStructuredProduct),
        /// Фонд. Заполняется только для фондов — тип актива `asset.type = ASSET_TYPE_SECURITY` и `security.type = etf`.
        #[prost(message, tag = "6")]
        Etf(super::AssetEtf),
        /// Клиринговый сертификат участия. Заполняется только для клиринговых сертификатов — тип актива `asset.type = ASSET_TYPE_SECURITY` и security.type = `clearing_certificate`.
        #[prost(message, tag = "7")]
        ClearingCertificate(super::AssetClearingCertificate),
    }
}
/// Акция.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetShare {
    /// Тип акции.
    #[prost(enumeration = "ShareType", tag = "1")]
    pub r#type: i32,
    /// Объем выпуска (шт.).
    #[prost(message, optional, tag = "2")]
    pub issue_size: ::core::option::Option<Quotation>,
    /// Номинал.
    #[prost(message, optional, tag = "3")]
    pub nominal: ::core::option::Option<Quotation>,
    /// Валюта номинала.
    #[prost(string, tag = "4")]
    pub nominal_currency: ::prost::alloc::string::String,
    /// Индекс (Bloomberg).
    #[prost(string, tag = "5")]
    pub primary_index: ::prost::alloc::string::String,
    /// Ставка дивиденда (для привилегированных акций).
    #[prost(message, optional, tag = "6")]
    pub dividend_rate: ::core::option::Option<Quotation>,
    /// Тип привилегированных акций.
    #[prost(string, tag = "7")]
    pub preferred_share_type: ::prost::alloc::string::String,
    /// Дата IPO.
    #[prost(message, optional, tag = "8")]
    pub ipo_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата регистрации.
    #[prost(message, optional, tag = "9")]
    pub registry_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Признак наличия дивидендной доходности.
    #[prost(bool, tag = "10")]
    pub div_yield_flag: bool,
    /// Форма выпуска ФИ.
    #[prost(string, tag = "11")]
    pub issue_kind: ::prost::alloc::string::String,
    /// Дата размещения акции.
    #[prost(message, optional, tag = "12")]
    pub placement_date: ::core::option::Option<::prost_types::Timestamp>,
    /// ISIN базового актива.
    #[prost(string, tag = "13")]
    pub repres_isin: ::prost::alloc::string::String,
    /// Объявленное количество, шт.
    #[prost(message, optional, tag = "14")]
    pub issue_size_plan: ::core::option::Option<Quotation>,
    /// Количество акций в свободном обращении.
    #[prost(message, optional, tag = "15")]
    pub total_float: ::core::option::Option<Quotation>,
}
/// Облигация.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetBond {
    /// Текущий номинал.
    #[prost(message, optional, tag = "1")]
    pub current_nominal: ::core::option::Option<Quotation>,
    /// Наименование заемщика.
    #[prost(string, tag = "2")]
    pub borrow_name: ::prost::alloc::string::String,
    /// Объем эмиссии облигации (стоимость).
    #[prost(message, optional, tag = "3")]
    pub issue_size: ::core::option::Option<Quotation>,
    /// Номинал облигации.
    #[prost(message, optional, tag = "4")]
    pub nominal: ::core::option::Option<Quotation>,
    /// Валюта номинала.
    #[prost(string, tag = "5")]
    pub nominal_currency: ::prost::alloc::string::String,
    /// Форма выпуска облигации.
    #[prost(string, tag = "6")]
    pub issue_kind: ::prost::alloc::string::String,
    /// Форма дохода облигации.
    #[prost(string, tag = "7")]
    pub interest_kind: ::prost::alloc::string::String,
    /// Количество выплат в год.
    #[prost(int32, tag = "8")]
    pub coupon_quantity_per_year: i32,
    /// Признак облигации с индексируемым номиналом.
    #[prost(bool, tag = "9")]
    pub indexed_nominal_flag: bool,
    /// Признак субординированной облигации.
    #[prost(bool, tag = "10")]
    pub subordinated_flag: bool,
    /// Признак обеспеченной облигации.
    #[prost(bool, tag = "11")]
    pub collateral_flag: bool,
    /// Признак показывает, что купоны облигации не облагаются налогом — для mass market.
    #[prost(bool, tag = "12")]
    pub tax_free_flag: bool,
    /// Признак облигации с амортизацией долга.
    #[prost(bool, tag = "13")]
    pub amortization_flag: bool,
    /// Признак облигации с плавающим купоном.
    #[prost(bool, tag = "14")]
    pub floating_coupon_flag: bool,
    /// Признак бессрочной облигации.
    #[prost(bool, tag = "15")]
    pub perpetual_flag: bool,
    /// Дата погашения облигации.
    #[prost(message, optional, tag = "16")]
    pub maturity_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Описание и условия получения дополнительного дохода.
    #[prost(string, tag = "17")]
    pub return_condition: ::prost::alloc::string::String,
    /// Дата выпуска облигации.
    #[prost(message, optional, tag = "18")]
    pub state_reg_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата размещения облигации.
    #[prost(message, optional, tag = "19")]
    pub placement_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Цена размещения облигации.
    #[prost(message, optional, tag = "20")]
    pub placement_price: ::core::option::Option<Quotation>,
    /// Объявленное количество, шт.
    #[prost(message, optional, tag = "21")]
    pub issue_size_plan: ::core::option::Option<Quotation>,
}
/// Структурная нота.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetStructuredProduct {
    /// Наименование заемщика.
    #[prost(string, tag = "1")]
    pub borrow_name: ::prost::alloc::string::String,
    /// Номинал.
    #[prost(message, optional, tag = "2")]
    pub nominal: ::core::option::Option<Quotation>,
    /// Валюта номинала.
    #[prost(string, tag = "3")]
    pub nominal_currency: ::prost::alloc::string::String,
    /// Тип структурной ноты.
    #[prost(enumeration = "StructuredProductType", tag = "4")]
    pub r#type: i32,
    /// Стратегия портфеля.
    #[prost(string, tag = "5")]
    pub logic_portfolio: ::prost::alloc::string::String,
    /// Тип базового актива.
    #[prost(enumeration = "AssetType", tag = "6")]
    pub asset_type: i32,
    /// Вид базового актива в зависимости от типа базового актива.
    #[prost(string, tag = "7")]
    pub basic_asset: ::prost::alloc::string::String,
    /// Барьер сохранности в процентах.
    #[prost(message, optional, tag = "8")]
    pub safety_barrier: ::core::option::Option<Quotation>,
    /// Дата погашения.
    #[prost(message, optional, tag = "9")]
    pub maturity_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Объявленное количество, шт.
    #[prost(message, optional, tag = "10")]
    pub issue_size_plan: ::core::option::Option<Quotation>,
    /// Объем размещения.
    #[prost(message, optional, tag = "11")]
    pub issue_size: ::core::option::Option<Quotation>,
    /// Дата размещения ноты.
    #[prost(message, optional, tag = "12")]
    pub placement_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Форма выпуска.
    #[prost(string, tag = "13")]
    pub issue_kind: ::prost::alloc::string::String,
}
/// Фонд.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetEtf {
    /// Суммарные расходы фонда в процентах.
    #[prost(message, optional, tag = "1")]
    pub total_expense: ::core::option::Option<Quotation>,
    /// Барьерная ставка доходности, после которой фонд имеет право на perfomance fee — в процентах.
    #[prost(message, optional, tag = "2")]
    pub hurdle_rate: ::core::option::Option<Quotation>,
    /// Комиссия за успешные результаты фонда в процентах.
    #[prost(message, optional, tag = "3")]
    pub performance_fee: ::core::option::Option<Quotation>,
    /// Фиксированная комиссия за управление в процентах.
    #[prost(message, optional, tag = "4")]
    pub fixed_commission: ::core::option::Option<Quotation>,
    /// Тип распределения доходов от выплат по бумагам.
    #[prost(string, tag = "5")]
    pub payment_type: ::prost::alloc::string::String,
    /// Признак необходимости выхода фонда в плюс для получения комиссии.
    #[prost(bool, tag = "6")]
    pub watermark_flag: bool,
    /// Премия (надбавка к цене) при покупке доли в фонде — в процентах.
    #[prost(message, optional, tag = "7")]
    pub buy_premium: ::core::option::Option<Quotation>,
    /// Ставка дисконта (вычет из цены) при продаже доли в фонде — в процентах.
    #[prost(message, optional, tag = "8")]
    pub sell_discount: ::core::option::Option<Quotation>,
    /// Признак ребалансируемости портфеля фонда.
    #[prost(bool, tag = "9")]
    pub rebalancing_flag: bool,
    /// Периодичность ребалансировки.
    #[prost(string, tag = "10")]
    pub rebalancing_freq: ::prost::alloc::string::String,
    /// Тип управления.
    #[prost(string, tag = "11")]
    pub management_type: ::prost::alloc::string::String,
    /// Индекс, который реплицирует (старается копировать) фонд.
    #[prost(string, tag = "12")]
    pub primary_index: ::prost::alloc::string::String,
    /// База ETF.
    #[prost(string, tag = "13")]
    pub focus_type: ::prost::alloc::string::String,
    /// Признак использования заемных активов (плечо).
    #[prost(bool, tag = "14")]
    pub leveraged_flag: bool,
    /// Количество акций в обращении.
    #[prost(message, optional, tag = "15")]
    pub num_share: ::core::option::Option<Quotation>,
    /// Признак обязательства по отчетности перед регулятором.
    #[prost(bool, tag = "16")]
    pub ucits_flag: bool,
    /// Дата выпуска.
    #[prost(message, optional, tag = "17")]
    pub released_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Описание фонда.
    #[prost(string, tag = "18")]
    pub description: ::prost::alloc::string::String,
    /// Описание индекса, за которым следует фонд.
    #[prost(string, tag = "19")]
    pub primary_index_description: ::prost::alloc::string::String,
    /// Основные компании, в которые вкладывается фонд.
    #[prost(string, tag = "20")]
    pub primary_index_company: ::prost::alloc::string::String,
    /// Срок восстановления индекса после просадки.
    #[prost(message, optional, tag = "21")]
    pub index_recovery_period: ::core::option::Option<Quotation>,
    /// IVAV-код.
    #[prost(string, tag = "22")]
    pub inav_code: ::prost::alloc::string::String,
    /// Признак наличия дивидендной доходности.
    #[prost(bool, tag = "23")]
    pub div_yield_flag: bool,
    /// Комиссия на покрытие расходов фонда в процентах.
    #[prost(message, optional, tag = "24")]
    pub expense_commission: ::core::option::Option<Quotation>,
    /// Ошибка следования за индексом в процентах.
    #[prost(message, optional, tag = "25")]
    pub primary_index_tracking_error: ::core::option::Option<Quotation>,
    /// Плановая ребалансировка портфеля.
    #[prost(string, tag = "26")]
    pub rebalancing_plan: ::prost::alloc::string::String,
    /// Ставки налогообложения дивидендов и купонов.
    #[prost(string, tag = "27")]
    pub tax_rate: ::prost::alloc::string::String,
    /// Даты ребалансировок.
    #[prost(message, repeated, tag = "28")]
    pub rebalancing_dates: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    /// Форма выпуска.
    #[prost(string, tag = "29")]
    pub issue_kind: ::prost::alloc::string::String,
    /// Номинал.
    #[prost(message, optional, tag = "30")]
    pub nominal: ::core::option::Option<Quotation>,
    /// Валюта номинала.
    #[prost(string, tag = "31")]
    pub nominal_currency: ::prost::alloc::string::String,
}
/// Клиринговый сертификат участия.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssetClearingCertificate {
    /// Номинал.
    #[prost(message, optional, tag = "1")]
    pub nominal: ::core::option::Option<Quotation>,
    /// Валюта номинала.
    #[prost(string, tag = "2")]
    pub nominal_currency: ::prost::alloc::string::String,
}
/// Бренд.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Brand {
    /// UID-идентификатор бренда.
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// Наименование бренда.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Информация о бренде.
    #[prost(string, tag = "4")]
    pub info: ::prost::alloc::string::String,
    /// Компания.
    #[prost(string, tag = "5")]
    pub company: ::prost::alloc::string::String,
    /// Сектор.
    #[prost(string, tag = "6")]
    pub sector: ::prost::alloc::string::String,
    /// Код страны риска.
    #[prost(string, tag = "7")]
    pub country_of_risk: ::prost::alloc::string::String,
    /// Наименование страны риска.
    #[prost(string, tag = "8")]
    pub country_of_risk_name: ::prost::alloc::string::String,
}
/// Идентификаторы инструмента.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetInstrument {
    /// UID-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "2")]
    pub figi: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(string, tag = "3")]
    pub instrument_type: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "4")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "5")]
    pub class_code: ::prost::alloc::string::String,
    /// Массив связанных инструментов.
    #[prost(message, repeated, tag = "6")]
    pub links: ::prost::alloc::vec::Vec<InstrumentLink>,
    /// Тип инструмента.
    #[prost(enumeration = "InstrumentType", tag = "10")]
    pub instrument_kind: i32,
    /// ID позиции.
    #[prost(string, tag = "11")]
    pub position_uid: ::prost::alloc::string::String,
}
/// Связь с другим инструментом.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentLink {
    /// Тип связи.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// UID-идентификатор связанного инструмента.
    #[prost(string, tag = "2")]
    pub instrument_uid: ::prost::alloc::string::String,
}
/// Запрос списка избранных инструментов, входные параметры не требуются.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFavoritesRequest {
    /// Уникальный идентификатор группы.
    #[prost(string, optional, tag = "1")]
    pub group_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// В ответ передается список избранных инструментов в качестве массива.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFavoritesResponse {
    /// Массив инструментов.
    #[prost(message, repeated, tag = "1")]
    pub favorite_instruments: ::prost::alloc::vec::Vec<FavoriteInstrument>,
    /// Уникальный идентификатор группы.
    #[prost(string, optional, tag = "2")]
    pub group_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Массив избранных инструментов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FavoriteInstrument {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код инструмента.
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// ISIN-идентификатор инструмента.
    #[prost(string, tag = "4")]
    pub isin: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(string, tag = "11")]
    pub instrument_type: ::prost::alloc::string::String,
    /// Название инструмента.
    #[prost(string, tag = "12")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "13")]
    pub uid: ::prost::alloc::string::String,
    /// Флаг, используемый ранее для определения внебиржевых инструментов. На данный момент не используется для торгуемых через API инструментов. Может использоваться как фильтр для операций, совершавшихся некоторое время назад на ОТС площадке.
    #[prost(bool, tag = "16")]
    pub otc_flag: bool,
    /// Возможность торговать инструментом через API.
    #[prost(bool, tag = "17")]
    pub api_trade_available_flag: bool,
    /// Тип инструмента.
    #[prost(enumeration = "InstrumentType", tag = "18")]
    pub instrument_kind: i32,
}
/// Запрос редактирования списка избранных инструментов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditFavoritesRequest {
    /// Массив инструментов.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<EditFavoritesRequestInstrument>,
    /// Тип действия со списком.
    #[prost(enumeration = "EditFavoritesActionType", tag = "6")]
    pub action_type: i32,
    /// Уникальный идентификатор группы.
    #[prost(string, optional, tag = "7")]
    pub group_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Массив инструментов для редактирования списка избранных инструментов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EditFavoritesRequestInstrument {
    /// FIGI-идентификатор инструмента.
    #[deprecated]
    #[prost(string, optional, tag = "1")]
    pub figi: ::core::option::Option<::prost::alloc::string::String>,
    /// Идентификатор инструмента — `figi` или `instrument_uid`.
    #[prost(string, tag = "2")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Результат редактирования списка избранных инструментов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditFavoritesResponse {
    /// Массив инструментов.
    #[prost(message, repeated, tag = "1")]
    pub favorite_instruments: ::prost::alloc::vec::Vec<FavoriteInstrument>,
    /// Уникальный идентификатор группы.
    #[prost(string, optional, tag = "2")]
    pub group_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Запрос создания новой группы избранных инструментов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateFavoriteGroupRequest {
    /// Название группы, не более 255 символов.
    #[prost(string, tag = "1")]
    pub group_name: ::prost::alloc::string::String,
    /// Цвет группы. Принимает значения в HEX-формате, от "000000" до "FFFFFF"
    #[prost(string, tag = "2")]
    pub group_color: ::prost::alloc::string::String,
    /// Описание
    #[prost(string, optional, tag = "3")]
    pub note: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateFavoriteGroupResponse {
    /// Уникальный идентификатор группы.
    #[prost(string, tag = "1")]
    pub group_id: ::prost::alloc::string::String,
    /// Название группы.
    #[prost(string, tag = "2")]
    pub group_name: ::prost::alloc::string::String,
}
/// Запрос удаления избранной группы
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFavoriteGroupRequest {
    /// Уникальный идентификатор группы.
    #[prost(string, tag = "1")]
    pub group_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFavoriteGroupResponse {}
/// Запрос получения списка избранных групп
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFavoriteGroupsRequest {
    /// Массив идентификаторов инструментов. Принимает значение `figi` или `instrument_uid`. Если в группе будет хотя бы один из инструментов массива, то в ответе у группы вернется признак `containsInstrument = true`.
    #[prost(string, repeated, tag = "1")]
    pub instrument_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Массив идентификаторов групп, которые необходимо исключить из ответа.
    #[prost(string, repeated, tag = "2")]
    pub excluded_group_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Избранные группы
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFavoriteGroupsResponse {
    /// Массив групп избранных списков инструментов.
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<get_favorite_groups_response::FavoriteGroup>,
}
/// Nested message and enum types in `GetFavoriteGroupsResponse`.
pub mod get_favorite_groups_response {
    /// Избранная группа
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FavoriteGroup {
        /// Уникальный идентификатор группы.
        #[prost(string, tag = "1")]
        pub group_id: ::prost::alloc::string::String,
        /// Название группы.
        #[prost(string, tag = "2")]
        pub group_name: ::prost::alloc::string::String,
        /// Цвет группы в HEX-формате.
        #[prost(string, tag = "3")]
        pub color: ::prost::alloc::string::String,
        /// Количество инструментов в группе.
        #[prost(int32, tag = "4")]
        pub size: i32,
        /// Признак наличия в группе хотя бы одного инструмента из запроса.
        #[prost(bool, optional, tag = "5")]
        pub contains_instrument: ::core::option::Option<bool>,
    }
}
/// Запрос справочника стран.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCountriesRequest {}
/// Справочник стран.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCountriesResponse {
    /// Массив стран.
    #[prost(message, repeated, tag = "1")]
    pub countries: ::prost::alloc::vec::Vec<CountryResponse>,
}
/// Запрос справочника индексов и товаров
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndicativesRequest {}
/// Справочник индексов и товаров
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndicativesResponse {
    /// Массив инструментов.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<IndicativeResponse>,
}
/// Индикатив
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IndicativeResponse {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "2")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код инструмента.
    #[prost(string, tag = "3")]
    pub class_code: ::prost::alloc::string::String,
    /// Валюта расчетов.
    #[prost(string, tag = "4")]
    pub currency: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(enumeration = "InstrumentType", tag = "10")]
    pub instrument_kind: i32,
    /// Название инструмента.
    #[prost(string, tag = "12")]
    pub name: ::prost::alloc::string::String,
    /// Tорговая площадка (секция биржи).
    #[prost(string, tag = "13")]
    pub exchange: ::prost::alloc::string::String,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "14")]
    pub uid: ::prost::alloc::string::String,
    /// Признак доступности для покупки.
    #[prost(bool, tag = "404")]
    pub buy_available_flag: bool,
    /// Признак доступности для продажи.
    #[prost(bool, tag = "405")]
    pub sell_available_flag: bool,
}
/// Данные о стране.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CountryResponse {
    /// Двухбуквенный код страны.
    #[prost(string, tag = "1")]
    pub alfa_two: ::prost::alloc::string::String,
    /// Трехбуквенный код страны.
    #[prost(string, tag = "2")]
    pub alfa_three: ::prost::alloc::string::String,
    /// Наименование страны.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Краткое наименование страны.
    #[prost(string, tag = "4")]
    pub name_brief: ::prost::alloc::string::String,
}
/// Запрос на поиск инструментов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FindInstrumentRequest {
    /// Строка поиска.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// Фильтр по типу инструмента.
    #[prost(enumeration = "InstrumentType", optional, tag = "2")]
    pub instrument_kind: ::core::option::Option<i32>,
    /// Фильтр для отображения только торговых инструментов.
    #[prost(bool, optional, tag = "3")]
    pub api_trade_available_flag: ::core::option::Option<bool>,
}
/// Результат поиска инструментов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindInstrumentResponse {
    /// Массив инструментов, удовлетворяющих условиям поиска.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<InstrumentShort>,
}
/// Краткая информация об инструменте.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentShort {
    /// ISIN инструмента.
    #[prost(string, tag = "1")]
    pub isin: ::prost::alloc::string::String,
    /// FIGI инструмента.
    #[prost(string, tag = "2")]
    pub figi: ::prost::alloc::string::String,
    /// Ticker инструмента.
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// ClassCode инструмента.
    #[prost(string, tag = "4")]
    pub class_code: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(string, tag = "5")]
    pub instrument_type: ::prost::alloc::string::String,
    /// Название инструмента.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный идентификатор инструмента.
    #[prost(string, tag = "7")]
    pub uid: ::prost::alloc::string::String,
    /// Уникальный идентификатор позиции инструмента.
    #[prost(string, tag = "8")]
    pub position_uid: ::prost::alloc::string::String,
    /// Тип инструмента.
    #[prost(enumeration = "InstrumentType", tag = "10")]
    pub instrument_kind: i32,
    /// Возможность торговать инструментом через API.
    #[prost(bool, tag = "11")]
    pub api_trade_available_flag: bool,
    /// Признак доступности для ИИС.
    #[prost(bool, tag = "12")]
    pub for_iis_flag: bool,
    /// Дата первой минутной свечи.
    #[prost(message, optional, tag = "26")]
    pub first_1min_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата первой дневной свечи.
    #[prost(message, optional, tag = "27")]
    pub first_1day_candle_date: ::core::option::Option<::prost_types::Timestamp>,
    /// Флаг, отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    #[prost(bool, tag = "28")]
    pub for_qual_investor_flag: bool,
    /// Флаг, отображающий доступность торговли инструментом по выходным.
    #[prost(bool, tag = "29")]
    pub weekend_flag: bool,
    /// Флаг заблокированного ТКС.
    #[prost(bool, tag = "30")]
    pub blocked_tca_flag: bool,
    /// Количество бумаг в лоте.
    #[prost(int32, tag = "31")]
    pub lot: i32,
}
/// Запрос списка брендов.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBrandsRequest {
    /// Настройки пагинации.
    #[prost(message, optional, tag = "1")]
    pub paging: ::core::option::Option<Page>,
}
/// Запрос бренда.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBrandRequest {
    /// UID-идентификатор бренда.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Список брендов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBrandsResponse {
    /// Массив брендов.
    #[prost(message, repeated, tag = "1")]
    pub brands: ::prost::alloc::vec::Vec<Brand>,
    /// Данные по пагинации.
    #[prost(message, optional, tag = "2")]
    pub paging: ::core::option::Option<PageResponse>,
}
/// Запрос фундаментальных показателей
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAssetFundamentalsRequest {
    /// Массив идентификаторов активов, не более 100 шт.
    #[prost(string, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Фундаментальные показатели
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetFundamentalsResponse {
    #[prost(message, repeated, tag = "1")]
    pub fundamentals: ::prost::alloc::vec::Vec<
        get_asset_fundamentals_response::StatisticResponse,
    >,
}
/// Nested message and enum types in `GetAssetFundamentalsResponse`.
pub mod get_asset_fundamentals_response {
    /// Фундаментальные показатели по активу
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatisticResponse {
        /// Идентификатор актива.
        #[prost(string, tag = "1")]
        pub asset_uid: ::prost::alloc::string::String,
        /// Валюта.
        #[prost(string, tag = "2")]
        pub currency: ::prost::alloc::string::String,
        /// Рыночная капитализация.
        #[prost(double, tag = "3")]
        pub market_capitalization: f64,
        /// Максимум за год.
        #[prost(double, tag = "4")]
        pub high_price_last_52_weeks: f64,
        /// Минимум за год.
        #[prost(double, tag = "5")]
        pub low_price_last_52_weeks: f64,
        /// Средний объем торгов за 10 дней.
        #[prost(double, tag = "6")]
        pub average_daily_volume_last_10_days: f64,
        /// Средний объем торгов за месяц.
        #[prost(double, tag = "7")]
        pub average_daily_volume_last_4_weeks: f64,
        #[prost(double, tag = "8")]
        pub beta: f64,
        /// Доля акций в свободном обращении.
        #[prost(double, tag = "9")]
        pub free_float: f64,
        /// Процент форвардной дивидендной доходности по отношению к цене акций.
        #[prost(double, tag = "10")]
        pub forward_annual_dividend_yield: f64,
        /// Количество акций в обращении.
        #[prost(double, tag = "11")]
        pub shares_outstanding: f64,
        /// Выручка.
        #[prost(double, tag = "12")]
        pub revenue_ttm: f64,
        /// EBITDA — прибыль до вычета процентов, налогов, износа и амортизации.
        #[prost(double, tag = "13")]
        pub ebitda_ttm: f64,
        /// Чистая прибыль.
        #[prost(double, tag = "14")]
        pub net_income_ttm: f64,
        /// EPS — величина чистой прибыли компании, которая приходится на каждую обыкновенную акцию.
        #[prost(double, tag = "15")]
        pub eps_ttm: f64,
        /// EPS компании с допущением, что все конвертируемые ценные бумаги компании были сконвертированы в обыкновенные акции.
        #[prost(double, tag = "16")]
        pub diluted_eps_ttm: f64,
        /// Свободный денежный поток.
        #[prost(double, tag = "17")]
        pub free_cash_flow_ttm: f64,
        /// Среднегодовой  рocт выручки за 5 лет.
        #[prost(double, tag = "18")]
        pub five_year_annual_revenue_growth_rate: f64,
        /// Среднегодовой  рocт выручки за 3 года.
        #[prost(double, tag = "19")]
        pub three_year_annual_revenue_growth_rate: f64,
        /// Соотношение рыночной капитализации компании к ее чистой прибыли.
        #[prost(double, tag = "20")]
        pub pe_ratio_ttm: f64,
        /// Соотношение рыночной капитализации компании к ее выручке.
        #[prost(double, tag = "21")]
        pub price_to_sales_ttm: f64,
        /// Соотношение рыночной капитализации компании к ее балансовой стоимости.
        #[prost(double, tag = "22")]
        pub price_to_book_ttm: f64,
        /// Соотношение рыночной капитализации компании к ее свободному денежному потоку.
        #[prost(double, tag = "23")]
        pub price_to_free_cash_flow_ttm: f64,
        /// Рыночная стоимость компании.
        #[prost(double, tag = "24")]
        pub total_enterprise_value_mrq: f64,
        /// Соотношение EV и EBITDA.
        #[prost(double, tag = "25")]
        pub ev_to_ebitda_mrq: f64,
        /// Маржа чистой прибыли.
        #[prost(double, tag = "26")]
        pub net_margin_mrq: f64,
        /// Рентабельность чистой прибыли.
        #[prost(double, tag = "27")]
        pub net_interest_margin_mrq: f64,
        /// Рентабельность собственного капитала.
        #[prost(double, tag = "28")]
        pub roe: f64,
        /// Рентабельность активов.
        #[prost(double, tag = "29")]
        pub roa: f64,
        /// Рентабельность активов.
        #[prost(double, tag = "30")]
        pub roic: f64,
        /// Сумма краткосрочных и долгосрочных обязательств компании.
        #[prost(double, tag = "31")]
        pub total_debt_mrq: f64,
        /// Соотношение долга к собственному капиталу.
        #[prost(double, tag = "32")]
        pub total_debt_to_equity_mrq: f64,
        /// Total Debt/EBITDA.
        #[prost(double, tag = "33")]
        pub total_debt_to_ebitda_mrq: f64,
        /// Отношение свободногоо кэша к стоимости.
        #[prost(double, tag = "34")]
        pub free_cash_flow_to_price: f64,
        /// Отношение чистого долга к EBITDA.
        #[prost(double, tag = "35")]
        pub net_debt_to_ebitda: f64,
        /// Коэффициент текущей ликвидности.
        #[prost(double, tag = "36")]
        pub current_ratio_mrq: f64,
        /// Коэффициент покрытия фиксированных платежей — FCCR.
        #[prost(double, tag = "37")]
        pub fixed_charge_coverage_ratio_fy: f64,
        /// Дивидендная доходность за 12 месяцев.
        #[prost(double, tag = "38")]
        pub dividend_yield_daily_ttm: f64,
        /// Выплаченные дивиденды за 12 месяцев.
        #[prost(double, tag = "39")]
        pub dividend_rate_ttm: f64,
        /// Значение дивидендов на акцию.
        #[prost(double, tag = "40")]
        pub dividends_per_share: f64,
        /// Средняя дивидендная доходность за 5 лет.
        #[prost(double, tag = "41")]
        pub five_years_average_dividend_yield: f64,
        /// Среднегодовой рост дивидендов за 5 лет.
        #[prost(double, tag = "42")]
        pub five_year_annual_dividend_growth_rate: f64,
        /// Процент чистой прибыли, уходящий на выплату дивидендов.
        #[prost(double, tag = "43")]
        pub dividend_payout_ratio_fy: f64,
        /// Деньги, потраченные на обратный выкуп акций.
        #[prost(double, tag = "44")]
        pub buy_back_ttm: f64,
        /// Рост выручки за 1 год.
        #[prost(double, tag = "45")]
        pub one_year_annual_revenue_growth_rate: f64,
        /// Код страны.
        #[prost(string, tag = "46")]
        pub domicile_indicator_code: ::prost::alloc::string::String,
        /// Соотношение депозитарной расписки к акциям.
        #[prost(double, tag = "47")]
        pub adr_to_common_share_ratio: f64,
        /// Количество сотрудников.
        #[prost(double, tag = "48")]
        pub number_of_employees: f64,
        #[prost(message, optional, tag = "49")]
        pub ex_dividend_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Начало фискального периода.
        #[prost(message, optional, tag = "50")]
        pub fiscal_period_start_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Окончание фискального периода.
        #[prost(message, optional, tag = "51")]
        pub fiscal_period_end_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Изменение общего дохода за 5 лет.
        #[prost(double, tag = "53")]
        pub revenue_change_five_years: f64,
        /// Изменение EPS за 5 лет.
        #[prost(double, tag = "54")]
        pub eps_change_five_years: f64,
        /// Изменение EBIDTA за 5 лет.
        #[prost(double, tag = "55")]
        pub ebitda_change_five_years: f64,
        /// Изменение общей задолжности за 5 лет.
        #[prost(double, tag = "56")]
        pub total_debt_change_five_years: f64,
        /// Отношение EV к выручке.
        #[prost(double, tag = "57")]
        pub ev_to_sales: f64,
    }
}
/// Запрос отчетов эмитентов
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAssetReportsRequest {
    /// Идентификатор инструмента в формате UID.
    #[prost(string, tag = "1")]
    pub instrument_id: ::prost::alloc::string::String,
    /// Начало запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
}
/// Отчеты эмитентов
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetReportsResponse {
    /// Массив событий по облигации.
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<
        get_asset_reports_response::GetAssetReportsEvent,
    >,
}
/// Nested message and enum types in `GetAssetReportsResponse`.
pub mod get_asset_reports_response {
    /// Отчет
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GetAssetReportsEvent {
        /// Идентификатор инструмента.
        #[prost(string, tag = "1")]
        pub instrument_id: ::prost::alloc::string::String,
        /// Дата публикации отчета.
        #[prost(message, optional, tag = "2")]
        pub report_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Год периода отчета.
        #[prost(int32, tag = "3")]
        pub period_year: i32,
        /// Номер периода.
        #[prost(int32, tag = "4")]
        pub period_num: i32,
        /// Тип отчета.
        #[prost(enumeration = "AssetReportPeriodType", tag = "5")]
        pub period_type: i32,
        /// Дата создания записи.
        #[prost(message, optional, tag = "6")]
        pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetReportPeriodType {
        /// Не указан.
        PeriodTypeUnspecified = 0,
        /// Квартальный.
        PeriodTypeQuarter = 1,
        /// Полугодовой.
        PeriodTypeSemiannual = 2,
        /// Годовой.
        PeriodTypeAnnual = 3,
    }
    impl AssetReportPeriodType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PeriodTypeUnspecified => "PERIOD_TYPE_UNSPECIFIED",
                Self::PeriodTypeQuarter => "PERIOD_TYPE_QUARTER",
                Self::PeriodTypeSemiannual => "PERIOD_TYPE_SEMIANNUAL",
                Self::PeriodTypeAnnual => "PERIOD_TYPE_ANNUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERIOD_TYPE_UNSPECIFIED" => Some(Self::PeriodTypeUnspecified),
                "PERIOD_TYPE_QUARTER" => Some(Self::PeriodTypeQuarter),
                "PERIOD_TYPE_SEMIANNUAL" => Some(Self::PeriodTypeSemiannual),
                "PERIOD_TYPE_ANNUAL" => Some(Self::PeriodTypeAnnual),
                _ => None,
            }
        }
    }
}
/// Запрос консенсус-прогнозов
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConsensusForecastsRequest {
    /// Настройки пагинации.
    #[prost(message, optional, tag = "1")]
    pub paging: ::core::option::Option<Page>,
}
/// Консенсус-прогнозы
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConsensusForecastsResponse {
    /// Массив прогнозов.
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<
        get_consensus_forecasts_response::ConsensusForecastsItem,
    >,
    /// Данные по пагинации.
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<PageResponse>,
}
/// Nested message and enum types in `GetConsensusForecastsResponse`.
pub mod get_consensus_forecasts_response {
    /// Прогноз
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ConsensusForecastsItem {
        /// UID-идентификатор.
        #[prost(string, tag = "1")]
        pub uid: ::prost::alloc::string::String,
        /// UID-идентификатор актива.
        #[prost(string, tag = "2")]
        pub asset_uid: ::prost::alloc::string::String,
        /// Дата и время создания записи.
        #[prost(message, optional, tag = "3")]
        pub created_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Целевая цена на 12 месяцев.
        #[prost(message, optional, tag = "4")]
        pub best_target_price: ::core::option::Option<super::Quotation>,
        /// Минимальная прогнозная цена.
        #[prost(message, optional, tag = "5")]
        pub best_target_low: ::core::option::Option<super::Quotation>,
        /// Максимальная прогнозная цена.
        #[prost(message, optional, tag = "6")]
        pub best_target_high: ::core::option::Option<super::Quotation>,
        /// Количество аналитиков рекомендующих покупать.
        #[prost(int32, tag = "7")]
        pub total_buy_recommend: i32,
        /// Количество аналитиков рекомендующих держать.
        #[prost(int32, tag = "8")]
        pub total_hold_recommend: i32,
        /// Количество аналитиков рекомендующих продавать.
        #[prost(int32, tag = "9")]
        pub total_sell_recommend: i32,
        /// Валюта прогнозов инструмента.
        #[prost(string, tag = "10")]
        pub currency: ::prost::alloc::string::String,
        /// Консенсус-прогноз.
        #[prost(enumeration = "super::Recommendation", tag = "11")]
        pub consensus: i32,
        /// Дата прогноза.
        #[prost(message, optional, tag = "12")]
        pub prognosis_date: ::core::option::Option<::prost_types::Timestamp>,
    }
}
/// Запрос прогнозов инвестдомов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetForecastRequest {
    /// Идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Прогнозы инвестдомов по инструменту.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetForecastResponse {
    /// Массив прогнозов.
    #[prost(message, repeated, tag = "1")]
    pub targets: ::prost::alloc::vec::Vec<get_forecast_response::TargetItem>,
    /// Согласованный прогноз.
    #[prost(message, optional, tag = "2")]
    pub consensus: ::core::option::Option<get_forecast_response::ConsensusItem>,
}
/// Nested message and enum types in `GetForecastResponse`.
pub mod get_forecast_response {
    /// Прогноз
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TargetItem {
        /// Уникальный идентификатор инструмента.
        #[prost(string, tag = "1")]
        pub uid: ::prost::alloc::string::String,
        /// Тикер инструмента.
        #[prost(string, tag = "2")]
        pub ticker: ::prost::alloc::string::String,
        /// Название компании, давшей прогноз.
        #[prost(string, tag = "3")]
        pub company: ::prost::alloc::string::String,
        /// Прогноз.
        #[prost(enumeration = "super::Recommendation", tag = "4")]
        pub recommendation: i32,
        /// Дата прогноза.
        #[prost(message, optional, tag = "5")]
        pub recommendation_date: ::core::option::Option<::prost_types::Timestamp>,
        /// Валюта.
        #[prost(string, tag = "6")]
        pub currency: ::prost::alloc::string::String,
        /// Текущая цена.
        #[prost(message, optional, tag = "7")]
        pub current_price: ::core::option::Option<super::Quotation>,
        /// Прогнозируемая цена.
        #[prost(message, optional, tag = "8")]
        pub target_price: ::core::option::Option<super::Quotation>,
        /// Изменение цены.
        #[prost(message, optional, tag = "9")]
        pub price_change: ::core::option::Option<super::Quotation>,
        /// Относительное изменение цены.
        #[prost(message, optional, tag = "10")]
        pub price_change_rel: ::core::option::Option<super::Quotation>,
        /// Наименование инструмента.
        #[prost(string, tag = "11")]
        pub show_name: ::prost::alloc::string::String,
    }
    /// Консенсус-прогноз.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ConsensusItem {
        /// Уникальный идентификатор инструмента.
        #[prost(string, tag = "1")]
        pub uid: ::prost::alloc::string::String,
        /// Тикер инструмента.
        #[prost(string, tag = "2")]
        pub ticker: ::prost::alloc::string::String,
        /// Прогноз.
        #[prost(enumeration = "super::Recommendation", tag = "3")]
        pub recommendation: i32,
        /// Валюта.
        #[prost(string, tag = "4")]
        pub currency: ::prost::alloc::string::String,
        /// Текущая цена.
        #[prost(message, optional, tag = "5")]
        pub current_price: ::core::option::Option<super::Quotation>,
        /// Прогнозируемая цена.
        #[prost(message, optional, tag = "6")]
        pub consensus: ::core::option::Option<super::Quotation>,
        /// Минимальная цена прогноза.
        #[prost(message, optional, tag = "7")]
        pub min_target: ::core::option::Option<super::Quotation>,
        /// Максимальная цена прогноза.
        #[prost(message, optional, tag = "8")]
        pub max_target: ::core::option::Option<super::Quotation>,
        /// Изменение цены.
        #[prost(message, optional, tag = "9")]
        pub price_change: ::core::option::Option<super::Quotation>,
        /// Относительное изменение цены.
        #[prost(message, optional, tag = "10")]
        pub price_change_rel: ::core::option::Option<super::Quotation>,
    }
}
/// Запрос ставок риска
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RiskRatesRequest {
    /// Идентификаторы инструментов.
    #[prost(string, repeated, tag = "1")]
    pub instrument_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Ставки риска
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskRatesResponse {
    #[prost(message, repeated, tag = "1")]
    pub instrument_risk_rates: ::prost::alloc::vec::Vec<
        risk_rates_response::RiskRateResult,
    >,
}
/// Nested message and enum types in `RiskRatesResponse`.
pub mod risk_rates_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RiskRateResult {
        #[prost(string, tag = "1")]
        pub instrument_uid: ::prost::alloc::string::String,
        /// Ставка риска пользователя  в шорт
        #[prost(message, optional, tag = "2")]
        pub short_risk_rate: ::core::option::Option<RiskRate>,
        /// Ставка риска пользователя в лонг
        #[prost(message, optional, tag = "3")]
        pub long_risk_rate: ::core::option::Option<RiskRate>,
        /// Доступные ставки риска в шорт
        #[prost(message, repeated, tag = "5")]
        pub short_risk_rates: ::prost::alloc::vec::Vec<RiskRate>,
        /// Доступные ставки риска в лонг
        #[prost(message, repeated, tag = "6")]
        pub long_risk_rates: ::prost::alloc::vec::Vec<RiskRate>,
        /// Ошибка.
        #[prost(string, optional, tag = "9")]
        pub error: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RiskRate {
        /// Категория риска.
        #[prost(string, tag = "2")]
        pub risk_level_code: ::prost::alloc::string::String,
        /// Значение ставки риска.
        #[prost(message, optional, tag = "5")]
        pub value: ::core::option::Option<super::Quotation>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradingInterval {
    /// Название интервала.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Интервал.
    #[prost(message, optional, tag = "2")]
    pub interval: ::core::option::Option<trading_interval::TimeInterval>,
}
/// Nested message and enum types in `TradingInterval`.
pub mod trading_interval {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TimeInterval {
        /// Время начала интервала.
        #[prost(message, optional, tag = "1")]
        pub start_ts: ::core::option::Option<::prost_types::Timestamp>,
        /// Время окончания интервала.
        #[prost(message, optional, tag = "2")]
        pub end_ts: ::core::option::Option<::prost_types::Timestamp>,
    }
}
/// Запрос сделок по инсайдерам
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetInsiderDealsRequest {
    #[prost(string, tag = "1")]
    pub instrument_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub limit: i32,
    #[prost(string, optional, tag = "3")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
}
/// сделки инсайдеров
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInsiderDealsResponse {
    /// Массив сделок.
    #[prost(message, repeated, tag = "1")]
    pub insider_deals: ::prost::alloc::vec::Vec<get_insider_deals_response::InsiderDeal>,
    /// Курсор для получения следующей страницы.
    #[prost(string, optional, tag = "2")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `GetInsiderDealsResponse`.
pub mod get_insider_deals_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InsiderDeal {
        /// Уникальный идентификатор сделки.
        #[prost(int64, tag = "1")]
        pub trade_id: i64,
        /// Направление сделки.
        #[prost(enumeration = "TradeDirection", tag = "2")]
        pub direction: i32,
        /// Валюта сделки.
        #[prost(string, tag = "3")]
        pub currency: ::prost::alloc::string::String,
        /// Дата сделки.
        #[prost(message, optional, tag = "4")]
        pub date: ::core::option::Option<::prost_types::Timestamp>,
        /// Количество.
        #[prost(int64, tag = "5")]
        pub quantity: i64,
        /// Цена.
        #[prost(message, optional, tag = "6")]
        pub price: ::core::option::Option<super::Quotation>,
        /// Уникальный идентификатор инструмента.
        #[prost(string, tag = "7")]
        pub instrument_uid: ::prost::alloc::string::String,
        /// Тикер инструмента.
        #[prost(string, tag = "8")]
        pub ticker: ::prost::alloc::string::String,
        /// Имя инвестора.
        #[prost(string, tag = "9")]
        pub investor_name: ::prost::alloc::string::String,
        /// Какое отношение покупатель/продавец имеет к эмитенту
        #[prost(string, tag = "10")]
        pub investor_position: ::prost::alloc::string::String,
        /// Купленный/проданный объём от общего количества ценных бумаг на рынке
        #[prost(float, tag = "11")]
        pub percentage: f32,
        /// Признак является ли сделка реализацией опциона
        #[prost(bool, tag = "12")]
        pub is_option_execution: bool,
        /// Дата раскрытия сделки.
        #[prost(message, optional, tag = "13")]
        pub disclosure_date: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TradeDirection {
        /// Не определено.
        Unspecified = 0,
        /// Покупка.
        Buy = 1,
        /// Продажа.
        Sell = 2,
        /// Увеличение доли.
        Increase = 3,
        /// Уменьшение доли.
        Decrease = 4,
    }
    impl TradeDirection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRADE_DIRECTION_UNSPECIFIED",
                Self::Buy => "TRADE_DIRECTION_BUY",
                Self::Sell => "TRADE_DIRECTION_SELL",
                Self::Increase => "TRADE_DIRECTION_INCREASE",
                Self::Decrease => "TRADE_DIRECTION_DECREASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRADE_DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "TRADE_DIRECTION_BUY" => Some(Self::Buy),
                "TRADE_DIRECTION_SELL" => Some(Self::Sell),
                "TRADE_DIRECTION_INCREASE" => Some(Self::Increase),
                "TRADE_DIRECTION_DECREASE" => Some(Self::Decrease),
                _ => None,
            }
        }
    }
}
/// Тип купонов.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CouponType {
    /// Неопределенное значение.
    Unspecified = 0,
    /// Постоянный.
    Constant = 1,
    /// Плавающий.
    Floating = 2,
    /// Дисконт.
    Discount = 3,
    /// Ипотечный.
    Mortgage = 4,
    /// Фиксированный.
    Fix = 5,
    /// Переменный.
    Variable = 6,
    /// Прочее.
    Other = 7,
}
impl CouponType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COUPON_TYPE_UNSPECIFIED",
            Self::Constant => "COUPON_TYPE_CONSTANT",
            Self::Floating => "COUPON_TYPE_FLOATING",
            Self::Discount => "COUPON_TYPE_DISCOUNT",
            Self::Mortgage => "COUPON_TYPE_MORTGAGE",
            Self::Fix => "COUPON_TYPE_FIX",
            Self::Variable => "COUPON_TYPE_VARIABLE",
            Self::Other => "COUPON_TYPE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COUPON_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "COUPON_TYPE_CONSTANT" => Some(Self::Constant),
            "COUPON_TYPE_FLOATING" => Some(Self::Floating),
            "COUPON_TYPE_DISCOUNT" => Some(Self::Discount),
            "COUPON_TYPE_MORTGAGE" => Some(Self::Mortgage),
            "COUPON_TYPE_FIX" => Some(Self::Fix),
            "COUPON_TYPE_VARIABLE" => Some(Self::Variable),
            "COUPON_TYPE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// Тип опциона по направлению сделки.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionDirection {
    /// Тип не определен.
    Unspecified = 0,
    /// Опцион на продажу.
    Put = 1,
    /// Опцион на покупку.
    Call = 2,
}
impl OptionDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPTION_DIRECTION_UNSPECIFIED",
            Self::Put => "OPTION_DIRECTION_PUT",
            Self::Call => "OPTION_DIRECTION_CALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPTION_DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "OPTION_DIRECTION_PUT" => Some(Self::Put),
            "OPTION_DIRECTION_CALL" => Some(Self::Call),
            _ => None,
        }
    }
}
/// Тип расчетов по опциону.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionPaymentType {
    /// Тип не определен.
    Unspecified = 0,
    /// Опционы с использованием премии в расчетах.
    Premium = 1,
    /// Маржируемые опционы.
    Marginal = 2,
}
impl OptionPaymentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPTION_PAYMENT_TYPE_UNSPECIFIED",
            Self::Premium => "OPTION_PAYMENT_TYPE_PREMIUM",
            Self::Marginal => "OPTION_PAYMENT_TYPE_MARGINAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPTION_PAYMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "OPTION_PAYMENT_TYPE_PREMIUM" => Some(Self::Premium),
            "OPTION_PAYMENT_TYPE_MARGINAL" => Some(Self::Marginal),
            _ => None,
        }
    }
}
/// Тип опциона по стилю.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionStyle {
    /// Тип не определен.
    Unspecified = 0,
    /// Американский опцион.
    American = 1,
    /// Европейский опцион.
    European = 2,
}
impl OptionStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPTION_STYLE_UNSPECIFIED",
            Self::American => "OPTION_STYLE_AMERICAN",
            Self::European => "OPTION_STYLE_EUROPEAN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPTION_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
            "OPTION_STYLE_AMERICAN" => Some(Self::American),
            "OPTION_STYLE_EUROPEAN" => Some(Self::European),
            _ => None,
        }
    }
}
/// Тип опциона по способу исполнения.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionSettlementType {
    /// Тип не определен.
    OptionExecutionTypeUnspecified = 0,
    /// Поставочный тип опциона.
    OptionExecutionTypePhysicalDelivery = 1,
    /// Расчетный тип опциона.
    OptionExecutionTypeCashSettlement = 2,
}
impl OptionSettlementType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OptionExecutionTypeUnspecified => "OPTION_EXECUTION_TYPE_UNSPECIFIED",
            Self::OptionExecutionTypePhysicalDelivery => {
                "OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY"
            }
            Self::OptionExecutionTypeCashSettlement => {
                "OPTION_EXECUTION_TYPE_CASH_SETTLEMENT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPTION_EXECUTION_TYPE_UNSPECIFIED" => {
                Some(Self::OptionExecutionTypeUnspecified)
            }
            "OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY" => {
                Some(Self::OptionExecutionTypePhysicalDelivery)
            }
            "OPTION_EXECUTION_TYPE_CASH_SETTLEMENT" => {
                Some(Self::OptionExecutionTypeCashSettlement)
            }
            _ => None,
        }
    }
}
/// Тип идентификатора инструмента. [Подробнее об идентификации инструментов](./faq_identification/).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentIdType {
    /// Значение не определено.
    InstrumentIdUnspecified = 0,
    /// FIGI.
    Figi = 1,
    /// Ticker.
    Ticker = 2,
    /// Уникальный идентификатор.
    Uid = 3,
    /// Идентификатор позиции.
    PositionUid = 4,
}
impl InstrumentIdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InstrumentIdUnspecified => "INSTRUMENT_ID_UNSPECIFIED",
            Self::Figi => "INSTRUMENT_ID_TYPE_FIGI",
            Self::Ticker => "INSTRUMENT_ID_TYPE_TICKER",
            Self::Uid => "INSTRUMENT_ID_TYPE_UID",
            Self::PositionUid => "INSTRUMENT_ID_TYPE_POSITION_UID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_ID_UNSPECIFIED" => Some(Self::InstrumentIdUnspecified),
            "INSTRUMENT_ID_TYPE_FIGI" => Some(Self::Figi),
            "INSTRUMENT_ID_TYPE_TICKER" => Some(Self::Ticker),
            "INSTRUMENT_ID_TYPE_UID" => Some(Self::Uid),
            "INSTRUMENT_ID_TYPE_POSITION_UID" => Some(Self::PositionUid),
            _ => None,
        }
    }
}
/// Тип акций.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ShareType {
    /// Значение не определено.
    Unspecified = 0,
    /// Обыкновенная.
    Common = 1,
    /// Привилегированная.
    Preferred = 2,
    /// Американские депозитарные расписки.
    Adr = 3,
    /// Глобальные депозитарные расписки.
    Gdr = 4,
    /// Товарищество с ограниченной ответственностью.
    Mlp = 5,
    /// Акции из реестра Нью-Йорка.
    NyRegShrs = 6,
    /// Закрытый инвестиционный фонд.
    ClosedEndFund = 7,
    /// Траст недвижимости.
    Reit = 8,
}
impl ShareType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SHARE_TYPE_UNSPECIFIED",
            Self::Common => "SHARE_TYPE_COMMON",
            Self::Preferred => "SHARE_TYPE_PREFERRED",
            Self::Adr => "SHARE_TYPE_ADR",
            Self::Gdr => "SHARE_TYPE_GDR",
            Self::Mlp => "SHARE_TYPE_MLP",
            Self::NyRegShrs => "SHARE_TYPE_NY_REG_SHRS",
            Self::ClosedEndFund => "SHARE_TYPE_CLOSED_END_FUND",
            Self::Reit => "SHARE_TYPE_REIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SHARE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SHARE_TYPE_COMMON" => Some(Self::Common),
            "SHARE_TYPE_PREFERRED" => Some(Self::Preferred),
            "SHARE_TYPE_ADR" => Some(Self::Adr),
            "SHARE_TYPE_GDR" => Some(Self::Gdr),
            "SHARE_TYPE_MLP" => Some(Self::Mlp),
            "SHARE_TYPE_NY_REG_SHRS" => Some(Self::NyRegShrs),
            "SHARE_TYPE_CLOSED_END_FUND" => Some(Self::ClosedEndFund),
            "SHARE_TYPE_REIT" => Some(Self::Reit),
            _ => None,
        }
    }
}
/// Тип актива.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssetType {
    /// Тип не определен.
    Unspecified = 0,
    /// Валюта.
    Currency = 1,
    /// Товар.
    Commodity = 2,
    /// Индекс.
    Index = 3,
    /// Ценная бумага.
    Security = 4,
}
impl AssetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ASSET_TYPE_UNSPECIFIED",
            Self::Currency => "ASSET_TYPE_CURRENCY",
            Self::Commodity => "ASSET_TYPE_COMMODITY",
            Self::Index => "ASSET_TYPE_INDEX",
            Self::Security => "ASSET_TYPE_SECURITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASSET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ASSET_TYPE_CURRENCY" => Some(Self::Currency),
            "ASSET_TYPE_COMMODITY" => Some(Self::Commodity),
            "ASSET_TYPE_INDEX" => Some(Self::Index),
            "ASSET_TYPE_SECURITY" => Some(Self::Security),
            _ => None,
        }
    }
}
/// Тип структурной ноты.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StructuredProductType {
    /// Тип не определен.
    SpTypeUnspecified = 0,
    /// Поставочный.
    SpTypeDeliverable = 1,
    /// Беспоставочный.
    SpTypeNonDeliverable = 2,
}
impl StructuredProductType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SpTypeUnspecified => "SP_TYPE_UNSPECIFIED",
            Self::SpTypeDeliverable => "SP_TYPE_DELIVERABLE",
            Self::SpTypeNonDeliverable => "SP_TYPE_NON_DELIVERABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SP_TYPE_UNSPECIFIED" => Some(Self::SpTypeUnspecified),
            "SP_TYPE_DELIVERABLE" => Some(Self::SpTypeDeliverable),
            "SP_TYPE_NON_DELIVERABLE" => Some(Self::SpTypeNonDeliverable),
            _ => None,
        }
    }
}
/// Тип действия со списком избранных инструментов.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EditFavoritesActionType {
    /// Тип не определен.
    Unspecified = 0,
    /// Добавить в список.
    Add = 1,
    /// Удалить из списка.
    Del = 2,
}
impl EditFavoritesActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED",
            Self::Add => "EDIT_FAVORITES_ACTION_TYPE_ADD",
            Self::Del => "EDIT_FAVORITES_ACTION_TYPE_DEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "EDIT_FAVORITES_ACTION_TYPE_ADD" => Some(Self::Add),
            "EDIT_FAVORITES_ACTION_TYPE_DEL" => Some(Self::Del),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Recommendation {
    /// Не определено.
    Unspecified = 0,
    /// Покупать.
    Buy = 1,
    /// Держать.
    Hold = 2,
    /// Продавать.
    Sell = 3,
}
impl Recommendation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RECOMMENDATION_UNSPECIFIED",
            Self::Buy => "RECOMMENDATION_BUY",
            Self::Hold => "RECOMMENDATION_HOLD",
            Self::Sell => "RECOMMENDATION_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECOMMENDATION_UNSPECIFIED" => Some(Self::Unspecified),
            "RECOMMENDATION_BUY" => Some(Self::Buy),
            "RECOMMENDATION_HOLD" => Some(Self::Hold),
            "RECOMMENDATION_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
/// Уровень риска облигации.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RiskLevel {
    /// Не указан.
    Unspecified = 0,
    /// Низкий уровень риска.
    Low = 1,
    /// Средний уровень риска.
    Moderate = 2,
    /// Высокий уровень риска.
    High = 3,
}
impl RiskLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RISK_LEVEL_UNSPECIFIED",
            Self::Low => "RISK_LEVEL_LOW",
            Self::Moderate => "RISK_LEVEL_MODERATE",
            Self::High => "RISK_LEVEL_HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RISK_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "RISK_LEVEL_LOW" => Some(Self::Low),
            "RISK_LEVEL_MODERATE" => Some(Self::Moderate),
            "RISK_LEVEL_HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BondType {
    /// Тип облигации не определен.
    Unspecified = 0,
    /// Замещающая облигация.
    Replaced = 1,
}
impl BondType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BOND_TYPE_UNSPECIFIED",
            Self::Replaced => "BOND_TYPE_REPLACED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BOND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BOND_TYPE_REPLACED" => Some(Self::Replaced),
            _ => None,
        }
    }
}
/// Площадка торговли.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentExchangeType {
    /// Площадка торговли не определена.
    InstrumentExchangeUnspecified = 0,
    /// Бумага, торгуемая у дилера.
    InstrumentExchangeDealer = 1,
}
impl InstrumentExchangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InstrumentExchangeUnspecified => "INSTRUMENT_EXCHANGE_UNSPECIFIED",
            Self::InstrumentExchangeDealer => "INSTRUMENT_EXCHANGE_DEALER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_EXCHANGE_UNSPECIFIED" => {
                Some(Self::InstrumentExchangeUnspecified)
            }
            "INSTRUMENT_EXCHANGE_DEALER" => Some(Self::InstrumentExchangeDealer),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod instruments_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct InstrumentsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl InstrumentsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> InstrumentsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstrumentsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            InstrumentsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// TradingSchedules — расписания торговых площадок
        pub async fn trading_schedules(
            &mut self,
            request: impl tonic::IntoRequest<super::TradingSchedulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TradingSchedulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/TradingSchedules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "TradingSchedules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// BondBy — получить облигацию по ее идентификатору
        pub async fn bond_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<tonic::Response<super::BondResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/BondBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "BondBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bonds — список облигаций
        pub async fn bonds(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<tonic::Response<super::BondsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Bonds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Bonds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetBondCoupons — график выплат купонов по облигации
        pub async fn get_bond_coupons(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBondCouponsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBondCouponsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBondCoupons",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetBondCoupons",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetBondEvents — события по облигации
        pub async fn get_bond_events(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBondEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBondEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBondEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetBondEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CurrencyBy — получить валюту по ее идентификатору
        pub async fn currency_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CurrencyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/CurrencyBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "CurrencyBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Currencies — список валют
        pub async fn currencies(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CurrenciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Currencies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Currencies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EtfBy — получить инвестиционный фонд по его идентификатору
        pub async fn etf_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<tonic::Response<super::EtfResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/EtfBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "EtfBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Etfs — список инвестиционных фондов
        pub async fn etfs(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<tonic::Response<super::EtfsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Etfs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Etfs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// FutureBy — получить фьючерс по его идентификатору
        pub async fn future_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<tonic::Response<super::FutureResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/FutureBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "FutureBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Futures — список фьючерсов
        pub async fn futures(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FuturesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Futures",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Futures",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// OptionBy — получить опцион по его идентификатору
        pub async fn option_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<tonic::Response<super::OptionResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/OptionBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "OptionBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated Options — список опционов
        #[deprecated]
        pub async fn options(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Options",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Options",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// OptionsBy — список опционов
        pub async fn options_by(
            &mut self,
            request: impl tonic::IntoRequest<super::FilterOptionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/OptionsBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "OptionsBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ShareBy — получить акцию по ее идентификатору
        pub async fn share_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<tonic::Response<super::ShareResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/ShareBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "ShareBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Shares — список акций
        pub async fn shares(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<tonic::Response<super::SharesResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Shares",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Shares",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Indicatives — индикативные инструменты — индексы, товары и другие
        pub async fn indicatives(
            &mut self,
            request: impl tonic::IntoRequest<super::IndicativesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IndicativesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Indicatives",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "Indicatives",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetAccruedInterests — накопленный купонный доход по облигации
        pub async fn get_accrued_interests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccruedInterestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAccruedInterestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAccruedInterests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetAccruedInterests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetFuturesMargin — размера гарантийного обеспечения по фьючерсам
        pub async fn get_futures_margin(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFuturesMarginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFuturesMarginResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFuturesMargin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetFuturesMargin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetInstrumentBy — основная информация об инструменте
        pub async fn get_instrument_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstrumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetInstrumentBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetInstrumentBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetDividends — события выплаты дивидендов по инструменту
        pub async fn get_dividends(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDividendsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDividendsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetDividends",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetDividends",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetAssetBy — получить актив по его идентификатору
        pub async fn get_asset_by(
            &mut self,
            request: impl tonic::IntoRequest<super::AssetRequest>,
        ) -> std::result::Result<tonic::Response<super::AssetResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssetBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetAssetBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetAssets — список активов
        /// Метод работает для всех инструментов, кроме срочных — фьючерсов и опционов
        pub async fn get_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::AssetsRequest>,
        ) -> std::result::Result<tonic::Response<super::AssetsResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetFavorites — получить список избранных инструментов
        pub async fn get_favorites(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFavoritesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFavoritesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFavorites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetFavorites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// EditFavorites — отредактировать список избранных инструментов
        pub async fn edit_favorites(
            &mut self,
            request: impl tonic::IntoRequest<super::EditFavoritesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EditFavoritesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/EditFavorites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "EditFavorites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CreateFavoriteGroup — создать новую группу избранных инструментов
        pub async fn create_favorite_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFavoriteGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateFavoriteGroupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/CreateFavoriteGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "CreateFavoriteGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeleteFavoriteGroup — удалить группу избранных инструментов
        pub async fn delete_favorite_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFavoriteGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteFavoriteGroupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/DeleteFavoriteGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "DeleteFavoriteGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetFavoriteGroups — список групп избранных инструментов
        pub async fn get_favorite_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFavoriteGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetFavoriteGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFavoriteGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetFavoriteGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetCountries — список стран
        pub async fn get_countries(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCountriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCountriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetCountries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetCountries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// FindInstrument — найти инструмент
        pub async fn find_instrument(
            &mut self,
            request: impl tonic::IntoRequest<super::FindInstrumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindInstrumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/FindInstrument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "FindInstrument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetBrands — список брендов
        pub async fn get_brands(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBrandsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBrandsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBrands",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetBrands",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetBrandBy — получить бренд по его идентификатору
        pub async fn get_brand_by(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBrandRequest>,
        ) -> std::result::Result<tonic::Response<super::Brand>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBrandBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetBrandBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetAssetFundamentals — фундаментальные показатели по активу
        pub async fn get_asset_fundamentals(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetFundamentalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAssetFundamentalsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssetFundamentals",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetAssetFundamentals",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetAssetReports — расписания выхода отчетностей эмитентов
        pub async fn get_asset_reports(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetReportsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAssetReportsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssetReports",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetAssetReports",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetConsensusForecasts — мнения аналитиков по инструменту
        pub async fn get_consensus_forecasts(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConsensusForecastsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConsensusForecastsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetConsensusForecasts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetConsensusForecasts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetForecastBy — прогнозы инвестдомов по инструменту
        pub async fn get_forecast_by(
            &mut self,
            request: impl tonic::IntoRequest<super::GetForecastRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetForecastResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetForecastBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetForecastBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetRiskRates — ставки риска по инструменту
        pub async fn get_risk_rates(
            &mut self,
            request: impl tonic::IntoRequest<super::RiskRatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RiskRatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetRiskRates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetRiskRates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetInsiderDeals —  сделки инсайдеров по инструментам
        pub async fn get_insider_deals(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInsiderDealsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetInsiderDealsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetInsiderDeals",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "GetInsiderDeals",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// StructuredNoteBy — получить структурную ноту по ее идентификатору
        pub async fn structured_note_by(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StructuredNoteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/StructuredNoteBy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "StructuredNoteBy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// StructuredNotes — список структурных нот
        pub async fn structured_notes(
            &mut self,
            request: impl tonic::IntoRequest<super::InstrumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StructuredNotesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.InstrumentsService/StructuredNotes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.InstrumentsService",
                        "StructuredNotes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Запрос подписки или отписки на определенные биржевые данные.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketDataRequest {
    #[prost(oneof = "market_data_request::Payload", tags = "1, 2, 3, 4, 5, 6, 7, 15")]
    pub payload: ::core::option::Option<market_data_request::Payload>,
}
/// Nested message and enum types in `MarketDataRequest`.
pub mod market_data_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Запрос подписки на свечи.
        #[prost(message, tag = "1")]
        SubscribeCandlesRequest(super::SubscribeCandlesRequest),
        /// Запрос подписки на стаканы.
        #[prost(message, tag = "2")]
        SubscribeOrderBookRequest(super::SubscribeOrderBookRequest),
        /// Запрос подписки на ленту обезличенных сделок.
        #[prost(message, tag = "3")]
        SubscribeTradesRequest(super::SubscribeTradesRequest),
        /// Запрос подписки на торговые статусы инструментов.
        #[prost(message, tag = "4")]
        SubscribeInfoRequest(super::SubscribeInfoRequest),
        /// Запрос подписки на цены последних сделок.
        #[prost(message, tag = "5")]
        SubscribeLastPriceRequest(super::SubscribeLastPriceRequest),
        /// Запрос своих подписок.
        #[prost(message, tag = "6")]
        GetMySubscriptions(super::GetMySubscriptions),
        /// Запрос проверки активности соединения.
        #[prost(message, tag = "7")]
        Ping(super::PingRequest),
        /// Запрос настройки пинга.
        #[prost(message, tag = "15")]
        PingSettings(super::PingDelaySettings),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketDataServerSideStreamRequest {
    /// Запрос подписки на свечи.
    #[prost(message, optional, tag = "1")]
    pub subscribe_candles_request: ::core::option::Option<SubscribeCandlesRequest>,
    /// Запрос подписки на стаканы.
    #[prost(message, optional, tag = "2")]
    pub subscribe_order_book_request: ::core::option::Option<SubscribeOrderBookRequest>,
    /// Запрос подписки на ленту обезличенных сделок.
    #[prost(message, optional, tag = "3")]
    pub subscribe_trades_request: ::core::option::Option<SubscribeTradesRequest>,
    /// Запрос подписки на торговые статусы инструментов.
    #[prost(message, optional, tag = "4")]
    pub subscribe_info_request: ::core::option::Option<SubscribeInfoRequest>,
    /// Запрос подписки на цены последних сделок.
    #[prost(message, optional, tag = "5")]
    pub subscribe_last_price_request: ::core::option::Option<SubscribeLastPriceRequest>,
    /// Запрос настройки пинга.
    #[prost(message, optional, tag = "15")]
    pub ping_settings: ::core::option::Option<PingDelaySettings>,
}
/// Пакет биржевой информации по подписке.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketDataResponse {
    #[prost(
        oneof = "market_data_response::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"
    )]
    pub payload: ::core::option::Option<market_data_response::Payload>,
}
/// Nested message and enum types in `MarketDataResponse`.
pub mod market_data_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Результат подписки на свечи.
        #[prost(message, tag = "1")]
        SubscribeCandlesResponse(super::SubscribeCandlesResponse),
        /// Результат подписки на стаканы.
        #[prost(message, tag = "2")]
        SubscribeOrderBookResponse(super::SubscribeOrderBookResponse),
        /// Результат подписки на поток обезличенных сделок.
        #[prost(message, tag = "3")]
        SubscribeTradesResponse(super::SubscribeTradesResponse),
        /// Результат подписки на торговые статусы инструментов.
        #[prost(message, tag = "4")]
        SubscribeInfoResponse(super::SubscribeInfoResponse),
        /// Свеча.
        #[prost(message, tag = "5")]
        Candle(super::Candle),
        /// Сделки.
        #[prost(message, tag = "6")]
        Trade(super::Trade),
        /// Стакан.
        #[prost(message, tag = "7")]
        Orderbook(super::OrderBook),
        /// Торговый статус.
        #[prost(message, tag = "8")]
        TradingStatus(super::TradingStatus),
        /// Проверка активности стрима.
        #[prost(message, tag = "9")]
        Ping(super::Ping),
        /// Результат подписки на цены последние сделок по инструментам.
        #[prost(message, tag = "10")]
        SubscribeLastPriceResponse(super::SubscribeLastPriceResponse),
        /// Цена последней сделки.
        #[prost(message, tag = "11")]
        LastPrice(super::LastPrice),
        /// Открытый интерес.
        #[prost(message, tag = "12")]
        OpenInterest(super::OpenInterest),
    }
}
/// subscribeCandles | Изменения статуса подписки на свечи.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCandlesRequest {
    /// Изменение статуса подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "1")]
    pub subscription_action: i32,
    /// Массив инструментов для подписки на свечи.
    #[prost(message, repeated, tag = "2")]
    pub instruments: ::prost::alloc::vec::Vec<CandleInstrument>,
    /// Флаг ожидания закрытия временного интервала для отправки свечи.
    #[prost(bool, tag = "3")]
    pub waiting_close: bool,
    /// Источник свечей.
    #[prost(enumeration = "get_candles_request::CandleSource", optional, tag = "9")]
    pub candle_source_type: ::core::option::Option<i32>,
}
/// Запрос изменения статус подписки на свечи.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CandleInstrument {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Интервал свечей. Двухчасовые и четырехчасовые свечи в стриме отсчитываются с 0:00 по UTC.
    #[prost(enumeration = "SubscriptionInterval", tag = "2")]
    pub interval: i32,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, tag = "3")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Результат изменения статус подписки на свечи.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCandlesResponse {
    /// Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
    #[prost(string, tag = "1")]
    pub tracking_id: ::prost::alloc::string::String,
    /// Массив статусов подписки на свечи.
    #[prost(message, repeated, tag = "2")]
    pub candles_subscriptions: ::prost::alloc::vec::Vec<CandleSubscription>,
}
/// Статус подписки на свечи.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CandleSubscription {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Интервал свечей.
    #[prost(enumeration = "SubscriptionInterval", tag = "2")]
    pub interval: i32,
    /// Статус подписки.
    #[prost(enumeration = "SubscriptionStatus", tag = "3")]
    pub subscription_status: i32,
    /// UID инструмента.
    #[prost(string, tag = "4")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Флаг ожидания закрытия временного интервала для отправки свечи.
    #[prost(bool, tag = "5")]
    pub waiting_close: bool,
    /// Идентификатор открытого соединения.
    #[prost(string, tag = "6")]
    pub stream_id: ::prost::alloc::string::String,
    /// Идентификатор подписки в формате `UUID`.
    #[prost(string, tag = "7")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Действие подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "8")]
    pub subscription_action: i32,
    /// Источник свечей.
    #[prost(enumeration = "get_candles_request::CandleSource", optional, tag = "9")]
    pub candle_source_type: ::core::option::Option<i32>,
    /// Тикер инструмента.
    #[prost(string, tag = "10")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "11")]
    pub class_code: ::prost::alloc::string::String,
}
/// Запрос на изменение статуса подписки на стаканы.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeOrderBookRequest {
    /// Изменение статуса подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "1")]
    pub subscription_action: i32,
    /// Массив инструментов для подписки на стаканы.
    #[prost(message, repeated, tag = "2")]
    pub instruments: ::prost::alloc::vec::Vec<OrderBookInstrument>,
}
/// Запрос подписки на стаканы.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderBookInstrument {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Глубина стакана.
    #[prost(int32, tag = "2")]
    pub depth: i32,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, tag = "3")]
    pub instrument_id: ::prost::alloc::string::String,
    /// Тип стакана. Значение по умолчанию — `ORDERBOOK_TYPE_ALL`, стакан биржевой и дилера.
    #[prost(enumeration = "OrderBookType", tag = "4")]
    pub order_book_type: i32,
}
/// Результат изменения статуса подписки на стаканы.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeOrderBookResponse {
    /// Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
    #[prost(string, tag = "1")]
    pub tracking_id: ::prost::alloc::string::String,
    /// Массив статусов подписки на стаканы.
    #[prost(message, repeated, tag = "2")]
    pub order_book_subscriptions: ::prost::alloc::vec::Vec<OrderBookSubscription>,
}
/// Статус подписки.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderBookSubscription {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Глубина стакана.
    #[prost(int32, tag = "2")]
    pub depth: i32,
    /// Статус подписки.
    #[prost(enumeration = "SubscriptionStatus", tag = "3")]
    pub subscription_status: i32,
    /// UID инструмента.
    #[prost(string, tag = "4")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Идентификатор открытого соединения.
    #[prost(string, tag = "5")]
    pub stream_id: ::prost::alloc::string::String,
    /// Идентификатор подписки в формате `UUID`.
    #[prost(string, tag = "6")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Тип стакана.
    #[prost(enumeration = "OrderBookType", tag = "7")]
    pub order_book_type: i32,
    /// Действие подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "8")]
    pub subscription_action: i32,
    /// Тикер инструмента.
    #[prost(string, tag = "9")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "10")]
    pub class_code: ::prost::alloc::string::String,
}
/// Изменение статуса подписки на поток обезличенных сделок.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeTradesRequest {
    /// Изменение статуса подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "1")]
    pub subscription_action: i32,
    /// Массив инструментов для подписки на поток обезличенных сделок.
    #[prost(message, repeated, tag = "2")]
    pub instruments: ::prost::alloc::vec::Vec<TradeInstrument>,
    /// Тип источника сделок. Значение по умолчанию — `TRADE_SOURCE_ALL`, все сделки.
    #[prost(enumeration = "TradeSourceType", tag = "3")]
    pub trade_source: i32,
    /// Флаг открытого интереса. **true** - в стриме дополнительно передается информация об открытом интересе для фьючерсов
    #[prost(bool, tag = "4")]
    pub with_open_interest: bool,
}
/// Запрос подписки на поток обезличенных сделок.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradeInstrument {
    /// Deprecated FIGI-идентификатор инструмента. Используйте instrument_id\`.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, tag = "2")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Результат изменения статуса подписки на поток обезличенных сделок.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeTradesResponse {
    /// Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
    #[prost(string, tag = "1")]
    pub tracking_id: ::prost::alloc::string::String,
    /// Массив статусов подписки на поток сделок.
    #[prost(message, repeated, tag = "2")]
    pub trade_subscriptions: ::prost::alloc::vec::Vec<TradeSubscription>,
    /// Тип источника сделок.
    #[prost(enumeration = "TradeSourceType", tag = "3")]
    pub trade_source: i32,
}
/// Статус подписки.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradeSubscription {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Статус подписки.
    #[prost(enumeration = "SubscriptionStatus", tag = "2")]
    pub subscription_status: i32,
    /// UID инструмента.
    #[prost(string, tag = "3")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Идентификатор открытого соединения.
    #[prost(string, tag = "4")]
    pub stream_id: ::prost::alloc::string::String,
    /// Идентификатор подписки в формате UUID.
    #[prost(string, tag = "5")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Флаг открытого интереса. **true** - в стриме дополнительно передается информация об открытом интересе для фьючерсов
    #[prost(bool, tag = "6")]
    pub with_open_interest: bool,
    /// Действие подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "7")]
    pub subscription_action: i32,
    /// Тикер инструмента.
    #[prost(string, tag = "8")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "9")]
    pub class_code: ::prost::alloc::string::String,
}
/// Изменение статуса подписки на торговый статус инструмента.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeInfoRequest {
    /// Изменение статуса подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "1")]
    pub subscription_action: i32,
    /// Массив инструментов для подписки на торговый статус.
    #[prost(message, repeated, tag = "2")]
    pub instruments: ::prost::alloc::vec::Vec<InfoInstrument>,
}
/// Запрос подписки на торговый статус.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InfoInstrument {
    /// Deprecated FIGI-идентификатор инструмента. Используйте instrument_id\`.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, tag = "2")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Результат изменения статуса подписки на торговый статус.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeInfoResponse {
    /// Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
    #[prost(string, tag = "1")]
    pub tracking_id: ::prost::alloc::string::String,
    /// Массив статусов подписки на торговый статус.
    #[prost(message, repeated, tag = "2")]
    pub info_subscriptions: ::prost::alloc::vec::Vec<InfoSubscription>,
}
/// Статус подписки.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InfoSubscription {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Статус подписки.
    #[prost(enumeration = "SubscriptionStatus", tag = "2")]
    pub subscription_status: i32,
    /// UID инструмента.
    #[prost(string, tag = "3")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Идентификатор открытого соединения.
    #[prost(string, tag = "4")]
    pub stream_id: ::prost::alloc::string::String,
    /// Идентификатор подписки в формате UUID.
    #[prost(string, tag = "5")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Действие подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "6")]
    pub subscription_action: i32,
    /// Тикер инструмента.
    #[prost(string, tag = "7")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "8")]
    pub class_code: ::prost::alloc::string::String,
}
/// Изменение статуса подписки на цену последней сделки по инструменту.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeLastPriceRequest {
    /// Изменение статуса подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "1")]
    pub subscription_action: i32,
    /// Массив инструментов для подписки на цену последней сделки.
    #[prost(message, repeated, tag = "2")]
    pub instruments: ::prost::alloc::vec::Vec<LastPriceInstrument>,
}
/// Запрос подписки на последнюю цену.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LastPriceInstrument {
    /// Deprecated FIGI-идентификатор инструмента. Используйте instrument_id\`.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, tag = "2")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Результат изменения статуса подписки на цену последней сделки.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeLastPriceResponse {
    /// Уникальный идентификатор запроса. [Подробнее](./grpc#tracking-id).
    #[prost(string, tag = "1")]
    pub tracking_id: ::prost::alloc::string::String,
    /// Массив статусов подписки на цену последней сделки.
    #[prost(message, repeated, tag = "2")]
    pub last_price_subscriptions: ::prost::alloc::vec::Vec<LastPriceSubscription>,
}
/// Статус подписки на цену последней сделки.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LastPriceSubscription {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Статус подписки.
    #[prost(enumeration = "SubscriptionStatus", tag = "2")]
    pub subscription_status: i32,
    /// UID инструмента.
    #[prost(string, tag = "3")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Идентификатор открытого соединения.
    #[prost(string, tag = "4")]
    pub stream_id: ::prost::alloc::string::String,
    /// Идентификатор подписки в формате `UUID`.
    #[prost(string, tag = "5")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Действие подписки.
    #[prost(enumeration = "SubscriptionAction", tag = "6")]
    pub subscription_action: i32,
    /// Тикер инструмента.
    #[prost(string, tag = "7")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "8")]
    pub class_code: ::prost::alloc::string::String,
}
/// Пакет свечей в рамках стрима.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Candle {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Интервал свечи.
    #[prost(enumeration = "SubscriptionInterval", tag = "2")]
    pub interval: i32,
    /// Цена открытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "3")]
    pub open: ::core::option::Option<Quotation>,
    /// Максимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "4")]
    pub high: ::core::option::Option<Quotation>,
    /// Минимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "5")]
    pub low: ::core::option::Option<Quotation>,
    /// Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "6")]
    pub close: ::core::option::Option<Quotation>,
    /// Объем сделок в лотах.
    #[prost(int64, tag = "7")]
    pub volume: i64,
    /// Время начала интервала свечи по UTC.
    #[prost(message, optional, tag = "8")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Время последней сделки, вошедшей в свечу по UTC.
    #[prost(message, optional, tag = "9")]
    pub last_trade_ts: ::core::option::Option<::prost_types::Timestamp>,
    /// UID инструмента.
    #[prost(string, tag = "10")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "11")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "12")]
    pub class_code: ::prost::alloc::string::String,
    /// Объем торгов на покупку.
    #[prost(int64, tag = "13")]
    pub volume_buy: i64,
    /// Объём торгов на продажу.
    #[prost(int64, tag = "14")]
    pub volume_sell: i64,
    /// Источник свечей.
    #[prost(enumeration = "CandleSource", tag = "19")]
    pub candle_source_type: i32,
}
/// Пакет стаканов в рамках стрима.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderBook {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Глубина стакана.
    #[prost(int32, tag = "2")]
    pub depth: i32,
    /// Флаг консистентности стакана. **false** — не все заявки попали в стакан из-за сетевых задержек или нарушения порядка доставки.
    #[prost(bool, tag = "3")]
    pub is_consistent: bool,
    /// Массив предложений.
    #[prost(message, repeated, tag = "4")]
    pub bids: ::prost::alloc::vec::Vec<Order>,
    /// Массив спроса.
    #[prost(message, repeated, tag = "5")]
    pub asks: ::prost::alloc::vec::Vec<Order>,
    /// Время формирования стакана в часовом поясе UTC по времени биржи.
    #[prost(message, optional, tag = "6")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Верхний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "7")]
    pub limit_up: ::core::option::Option<Quotation>,
    /// Нижний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "8")]
    pub limit_down: ::core::option::Option<Quotation>,
    /// UID инструмента.
    #[prost(string, tag = "9")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тип стакана.
    #[prost(enumeration = "OrderBookType", tag = "10")]
    pub order_book_type: i32,
    /// Тикер инструмента.
    #[prost(string, tag = "11")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "12")]
    pub class_code: ::prost::alloc::string::String,
}
/// Массив предложений/спроса.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Order {
    /// Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "1")]
    pub price: ::core::option::Option<Quotation>,
    /// Количество в лотах.
    #[prost(int64, tag = "2")]
    pub quantity: i64,
}
/// Информация о сделке.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Trade {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Направление сделки.
    #[prost(enumeration = "TradeDirection", tag = "2")]
    pub direction: i32,
    /// Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "3")]
    pub price: ::core::option::Option<Quotation>,
    /// Количество лотов.
    #[prost(int64, tag = "4")]
    pub quantity: i64,
    /// Время сделки в часовом поясе UTC по времени биржи.
    #[prost(message, optional, tag = "5")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// UID инструмента.
    #[prost(string, tag = "6")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тип источника сделки.
    #[prost(enumeration = "TradeSourceType", tag = "7")]
    pub trade_source: i32,
    /// Тикер инструмента.
    #[prost(string, tag = "8")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "9")]
    pub class_code: ::prost::alloc::string::String,
}
/// Пакет изменения торгового статуса.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradingStatus {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Статус торговли инструментом.
    #[prost(enumeration = "SecurityTradingStatus", tag = "2")]
    pub trading_status: i32,
    /// Время изменения торгового статуса по UTC.
    #[prost(message, optional, tag = "3")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Признак доступности выставления лимитной заявки по инструменту.
    #[prost(bool, tag = "4")]
    pub limit_order_available_flag: bool,
    /// Признак доступности выставления рыночной заявки по инструменту.
    #[prost(bool, tag = "5")]
    pub market_order_available_flag: bool,
    /// UID инструмента.
    #[prost(string, tag = "6")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "7")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "8")]
    pub class_code: ::prost::alloc::string::String,
}
/// Запрос исторических свечей.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCandlesRequest {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, optional, tag = "1")]
    pub figi: ::core::option::Option<::prost::alloc::string::String>,
    /// Начало запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Интервал запрошенных свечей.
    #[prost(enumeration = "CandleInterval", tag = "4")]
    pub interval: i32,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, optional, tag = "5")]
    pub instrument_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Тип источника свечи.
    #[prost(enumeration = "get_candles_request::CandleSource", optional, tag = "7")]
    pub candle_source_type: ::core::option::Option<i32>,
    /// Максимальное количество свечей в ответе.
    #[prost(int32, optional, tag = "10")]
    pub limit: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GetCandlesRequest`.
pub mod get_candles_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CandleSource {
        /// Все свечи.
        Unspecified = 0,
        /// Биржевые свечи.
        Exchange = 1,
        /// Все свечи с учетом торговли по выходным.
        IncludeWeekend = 3,
    }
    impl CandleSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CANDLE_SOURCE_UNSPECIFIED",
                Self::Exchange => "CANDLE_SOURCE_EXCHANGE",
                Self::IncludeWeekend => "CANDLE_SOURCE_INCLUDE_WEEKEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CANDLE_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                "CANDLE_SOURCE_EXCHANGE" => Some(Self::Exchange),
                "CANDLE_SOURCE_INCLUDE_WEEKEND" => Some(Self::IncludeWeekend),
                _ => None,
            }
        }
    }
}
/// Список свечей.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCandlesResponse {
    /// Массив свечей.
    #[prost(message, repeated, tag = "1")]
    pub candles: ::prost::alloc::vec::Vec<HistoricCandle>,
}
/// Информация о свече.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HistoricCandle {
    /// Цена открытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "1")]
    pub open: ::core::option::Option<Quotation>,
    /// Максимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "2")]
    pub high: ::core::option::Option<Quotation>,
    /// Минимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "3")]
    pub low: ::core::option::Option<Quotation>,
    /// Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "4")]
    pub close: ::core::option::Option<Quotation>,
    /// Объем торгов в лотах.
    #[prost(int64, tag = "5")]
    pub volume: i64,
    /// Время свечи в часовом поясе UTC.
    #[prost(message, optional, tag = "6")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Признак завершенности свечи. **false** — свеча за текущие интервал еще сформирована не полностью.
    #[prost(bool, tag = "7")]
    pub is_complete: bool,
    /// Тип источника свечи
    #[prost(enumeration = "CandleSource", tag = "9")]
    pub candle_source: i32,
    /// Объем торгов на покупку.
    #[prost(int64, tag = "10")]
    pub volume_buy: i64,
    /// Объём торгов на продажу.
    #[prost(int64, tag = "11")]
    pub volume_sell: i64,
}
/// Запрос получения цен последних сделок.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetLastPricesRequest {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, repeated, tag = "1")]
    pub figi: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Массив идентификаторов инструмента. Принимает значения `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, repeated, tag = "2")]
    pub instrument_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Тип запрашиваемой последней цены.
    #[prost(enumeration = "LastPriceType", tag = "3")]
    pub last_price_type: i32,
    /// Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus).
    #[prost(enumeration = "InstrumentStatus", optional, tag = "9")]
    pub instrument_status: ::core::option::Option<i32>,
}
/// Список цен последних сделок.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLastPricesResponse {
    /// Массив цен последних сделок.
    #[prost(message, repeated, tag = "1")]
    pub last_prices: ::prost::alloc::vec::Vec<LastPrice>,
}
/// Информация о цене последней сделки.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LastPrice {
    /// FIGI инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Цена последней сделки за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "2")]
    pub price: ::core::option::Option<Quotation>,
    /// Время получения последней цены в часовом поясе UTC по времени биржи.
    #[prost(message, optional, tag = "3")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Тикер инструмента.
    #[prost(string, tag = "9")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "10")]
    pub class_code: ::prost::alloc::string::String,
    /// UID инструмента.
    #[prost(string, tag = "11")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тип последней цены.
    #[prost(enumeration = "LastPriceType", tag = "12")]
    pub last_price_type: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpenInterest {
    /// UID инструмента.
    #[prost(string, tag = "1")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Время получения открытого интереса в часовом поясе UTC по времени биржи.
    #[prost(message, optional, tag = "2")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Открытый интерес.
    #[prost(int64, tag = "3")]
    pub open_interest: i64,
    /// Тикер инструмента.
    #[prost(string, tag = "4")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "5")]
    pub class_code: ::prost::alloc::string::String,
}
/// Запрос стакана.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOrderBookRequest {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, optional, tag = "1")]
    pub figi: ::core::option::Option<::prost::alloc::string::String>,
    /// Глубина стакана.
    #[prost(int32, tag = "2")]
    pub depth: i32,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, optional, tag = "3")]
    pub instrument_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Информация о стакане.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrderBookResponse {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Глубина стакана.
    #[prost(int32, tag = "2")]
    pub depth: i32,
    /// Множество пар значений на покупку.
    #[prost(message, repeated, tag = "3")]
    pub bids: ::prost::alloc::vec::Vec<Order>,
    /// Множество пар значений на продажу.
    #[prost(message, repeated, tag = "4")]
    pub asks: ::prost::alloc::vec::Vec<Order>,
    /// Цена последней сделки за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "5")]
    pub last_price: ::core::option::Option<Quotation>,
    /// Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "6")]
    pub close_price: ::core::option::Option<Quotation>,
    /// Верхний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "7")]
    pub limit_up: ::core::option::Option<Quotation>,
    /// Нижний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](./faq_marketdata/#_15).
    #[prost(message, optional, tag = "8")]
    pub limit_down: ::core::option::Option<Quotation>,
    /// UID инструмента.
    #[prost(string, tag = "9")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "10")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "11")]
    pub class_code: ::prost::alloc::string::String,
    /// Время получения цены последней сделки.
    #[prost(message, optional, tag = "21")]
    pub last_price_ts: ::core::option::Option<::prost_types::Timestamp>,
    /// Время получения цены закрытия.
    #[prost(message, optional, tag = "22")]
    pub close_price_ts: ::core::option::Option<::prost_types::Timestamp>,
    /// Время формирования стакана на бирже.
    #[prost(message, optional, tag = "23")]
    pub orderbook_ts: ::core::option::Option<::prost_types::Timestamp>,
}
/// Запрос получения торгового статуса.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTradingStatusRequest {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, optional, tag = "1")]
    pub figi: ::core::option::Option<::prost::alloc::string::String>,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`
    #[prost(string, optional, tag = "2")]
    pub instrument_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Запрос получения торгового статуса.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTradingStatusesRequest {
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`
    #[prost(string, repeated, tag = "1")]
    pub instrument_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Информация о торговом статусе.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTradingStatusesResponse {
    /// Массив информации о торговых статусах.
    #[prost(message, repeated, tag = "1")]
    pub trading_statuses: ::prost::alloc::vec::Vec<GetTradingStatusResponse>,
}
/// Информация о торговом статусе.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTradingStatusResponse {
    /// FIGI-идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// Статус торговли инструментом.
    #[prost(enumeration = "SecurityTradingStatus", tag = "2")]
    pub trading_status: i32,
    /// Признак доступности выставления лимитной заявки по инструменту.
    #[prost(bool, tag = "3")]
    pub limit_order_available_flag: bool,
    /// Признак доступности выставления рыночной заявки по инструменту.
    #[prost(bool, tag = "4")]
    pub market_order_available_flag: bool,
    /// Признак доступности торгов через API.
    #[prost(bool, tag = "5")]
    pub api_trade_available_flag: bool,
    /// UID инструмента.
    #[prost(string, tag = "6")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Признак доступности завяки по лучшей цене.
    #[prost(bool, tag = "8")]
    pub bestprice_order_available_flag: bool,
    /// Признак доступности только заявки по лучшей цене.
    #[prost(bool, tag = "9")]
    pub only_best_price: bool,
    /// Тикер инструмента.
    #[prost(string, tag = "10")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "11")]
    pub class_code: ::prost::alloc::string::String,
}
/// Запрос обезличенных сделок за последний час.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetLastTradesRequest {
    /// Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
    #[deprecated]
    #[prost(string, optional, tag = "1")]
    pub figi: ::core::option::Option<::prost::alloc::string::String>,
    /// Начало запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`
    #[prost(string, optional, tag = "4")]
    pub instrument_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Тип источника сделок. Значение по умолчанию — `TRADE_SOURCE_ALL`, все сделки.
    #[prost(enumeration = "TradeSourceType", tag = "5")]
    pub trade_source: i32,
}
/// Обезличенных сделок за последний час.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLastTradesResponse {
    /// Массив сделок.
    #[prost(message, repeated, tag = "1")]
    pub trades: ::prost::alloc::vec::Vec<Trade>,
}
/// Запрос активных подписок. Возвращает по одному сообщению на каждый тип активных подписок — `SubscribeLastPriceResponse`, `SubscribeInfoResponse`, `SubscribeTradesResponse`, `SubscribeOrderBookResponse`, `SubscribeCandlesResponse`.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMySubscriptions {}
/// Запрос цен закрытия торговой сессии по инструментам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClosePricesRequest {
    /// Массив по инструментам.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<InstrumentClosePriceRequest>,
    /// Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus).
    #[prost(enumeration = "InstrumentStatus", optional, tag = "9")]
    pub instrument_status: ::core::option::Option<i32>,
}
/// Запрос цен закрытия торговой сессии по инструменту.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentClosePriceRequest {
    /// Идентификатор инструмента. Принимает значение `figi`, `instrument_uid` или `ticker + '_' + class_code`
    #[prost(string, tag = "1")]
    pub instrument_id: ::prost::alloc::string::String,
}
/// Цены закрытия торговой сессии по инструментам.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClosePricesResponse {
    /// Массив по инструментам.
    #[prost(message, repeated, tag = "1")]
    pub close_prices: ::prost::alloc::vec::Vec<InstrumentClosePriceResponse>,
}
/// Цена закрытия торговой сессии по инструменту.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstrumentClosePriceResponse {
    /// FIGI инструмента.
    #[prost(string, tag = "1")]
    pub figi: ::prost::alloc::string::String,
    /// UID инструмента.
    #[prost(string, tag = "2")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Тикер инструмента.
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "4")]
    pub class_code: ::prost::alloc::string::String,
    /// Цена закрытия торговой сессии.
    #[prost(message, optional, tag = "11")]
    pub price: ::core::option::Option<Quotation>,
    /// Цена последней сделки с вечерней сессии. Цена публикуется биржей по торговым дням и в нерабочие дни не обновляется.
    #[prost(message, optional, tag = "12")]
    pub evening_session_price: ::core::option::Option<Quotation>,
    /// Дата совершения торгов.
    #[prost(message, optional, tag = "21")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Дата цены закрытия вечерней сессии.
    #[prost(message, optional, tag = "23")]
    pub evening_session_price_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTechAnalysisRequest {
    /// Тип технического индикатора.
    #[prost(enumeration = "get_tech_analysis_request::IndicatorType", tag = "1")]
    pub indicator_type: i32,
    /// UID инструмента.
    #[prost(string, tag = "2")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Начало запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "3")]
    pub from: ::core::option::Option<::prost_types::Timestamp>,
    /// Окончание запрашиваемого периода по UTC.
    #[prost(message, optional, tag = "4")]
    pub to: ::core::option::Option<::prost_types::Timestamp>,
    /// Интервал, за который рассчитывается индикатор.
    #[prost(enumeration = "get_tech_analysis_request::IndicatorInterval", tag = "5")]
    pub interval: i32,
    /// Тип цены, который используется при расчете индикатора.
    #[prost(enumeration = "get_tech_analysis_request::TypeOfPrice", tag = "6")]
    pub type_of_price: i32,
    /// Торговый период, за который рассчитывается индикатор.
    #[prost(int32, tag = "7")]
    pub length: i32,
    /// Параметры отклонения.
    #[prost(message, optional, tag = "8")]
    pub deviation: ::core::option::Option<get_tech_analysis_request::Deviation>,
    /// Параметры сглаживания.
    #[prost(message, optional, tag = "9")]
    pub smoothing: ::core::option::Option<get_tech_analysis_request::Smoothing>,
}
/// Nested message and enum types in `GetTechAnalysisRequest`.
pub mod get_tech_analysis_request {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Smoothing {
        /// Короткий период сглаживания для первой экспоненциальной скользящей средней (EMA).
        #[prost(int32, tag = "1")]
        pub fast_length: i32,
        /// Длинный период сглаживания для второй экспоненциальной скользящей средней (EMA).
        #[prost(int32, tag = "2")]
        pub slow_length: i32,
        /// Период сглаживания для третьей экспоненциальной скользящей средней (EMA)
        #[prost(int32, tag = "3")]
        pub signal_smoothing: i32,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Deviation {
        /// Количество стандартных отклонений, на которые отступают верхняя и нижняя границы.
        #[prost(message, optional, tag = "1")]
        pub deviation_multiplier: ::core::option::Option<super::Quotation>,
    }
    /// Интервал свечи.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IndicatorInterval {
        /// Интервал не определен.
        Unspecified = 0,
        /// 1 минута.
        OneMinute = 1,
        /// 5 минут.
        FiveMinutes = 2,
        /// 15 минут.
        FifteenMinutes = 3,
        /// 1 час.
        OneHour = 4,
        /// 1 день.
        OneDay = 5,
        /// 2 минуты.
        IndicatorInterval2Min = 6,
        /// 3 минуты.
        IndicatorInterval3Min = 7,
        /// 10 минут.
        IndicatorInterval10Min = 8,
        /// 30 минут.
        IndicatorInterval30Min = 9,
        /// 2 часа.
        IndicatorInterval2Hour = 10,
        /// 4 часа.
        IndicatorInterval4Hour = 11,
        /// Неделя.
        Week = 12,
        /// Месяц.
        Month = 13,
    }
    impl IndicatorInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INDICATOR_INTERVAL_UNSPECIFIED",
                Self::OneMinute => "INDICATOR_INTERVAL_ONE_MINUTE",
                Self::FiveMinutes => "INDICATOR_INTERVAL_FIVE_MINUTES",
                Self::FifteenMinutes => "INDICATOR_INTERVAL_FIFTEEN_MINUTES",
                Self::OneHour => "INDICATOR_INTERVAL_ONE_HOUR",
                Self::OneDay => "INDICATOR_INTERVAL_ONE_DAY",
                Self::IndicatorInterval2Min => "INDICATOR_INTERVAL_2_MIN",
                Self::IndicatorInterval3Min => "INDICATOR_INTERVAL_3_MIN",
                Self::IndicatorInterval10Min => "INDICATOR_INTERVAL_10_MIN",
                Self::IndicatorInterval30Min => "INDICATOR_INTERVAL_30_MIN",
                Self::IndicatorInterval2Hour => "INDICATOR_INTERVAL_2_HOUR",
                Self::IndicatorInterval4Hour => "INDICATOR_INTERVAL_4_HOUR",
                Self::Week => "INDICATOR_INTERVAL_WEEK",
                Self::Month => "INDICATOR_INTERVAL_MONTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INDICATOR_INTERVAL_UNSPECIFIED" => Some(Self::Unspecified),
                "INDICATOR_INTERVAL_ONE_MINUTE" => Some(Self::OneMinute),
                "INDICATOR_INTERVAL_FIVE_MINUTES" => Some(Self::FiveMinutes),
                "INDICATOR_INTERVAL_FIFTEEN_MINUTES" => Some(Self::FifteenMinutes),
                "INDICATOR_INTERVAL_ONE_HOUR" => Some(Self::OneHour),
                "INDICATOR_INTERVAL_ONE_DAY" => Some(Self::OneDay),
                "INDICATOR_INTERVAL_2_MIN" => Some(Self::IndicatorInterval2Min),
                "INDICATOR_INTERVAL_3_MIN" => Some(Self::IndicatorInterval3Min),
                "INDICATOR_INTERVAL_10_MIN" => Some(Self::IndicatorInterval10Min),
                "INDICATOR_INTERVAL_30_MIN" => Some(Self::IndicatorInterval30Min),
                "INDICATOR_INTERVAL_2_HOUR" => Some(Self::IndicatorInterval2Hour),
                "INDICATOR_INTERVAL_4_HOUR" => Some(Self::IndicatorInterval4Hour),
                "INDICATOR_INTERVAL_WEEK" => Some(Self::Week),
                "INDICATOR_INTERVAL_MONTH" => Some(Self::Month),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TypeOfPrice {
        /// Не указано.
        Unspecified = 0,
        /// Цена закрытия.
        Close = 1,
        /// Цена открытия.
        Open = 2,
        /// Максимальное значение за выбранный интервал.
        High = 3,
        /// Минимальное значение за выбранный интервал.
        Low = 4,
        /// Среднее значение по показателям \[ (close + open + high + low) / 4 \].
        Avg = 5,
    }
    impl TypeOfPrice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_OF_PRICE_UNSPECIFIED",
                Self::Close => "TYPE_OF_PRICE_CLOSE",
                Self::Open => "TYPE_OF_PRICE_OPEN",
                Self::High => "TYPE_OF_PRICE_HIGH",
                Self::Low => "TYPE_OF_PRICE_LOW",
                Self::Avg => "TYPE_OF_PRICE_AVG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_OF_PRICE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_OF_PRICE_CLOSE" => Some(Self::Close),
                "TYPE_OF_PRICE_OPEN" => Some(Self::Open),
                "TYPE_OF_PRICE_HIGH" => Some(Self::High),
                "TYPE_OF_PRICE_LOW" => Some(Self::Low),
                "TYPE_OF_PRICE_AVG" => Some(Self::Avg),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IndicatorType {
        /// Не определен.
        Unspecified = 0,
        /// Bollinger Bands — линия Боллинжера.
        Bb = 1,
        /// Exponential Moving Average — EMA, экспоненциальная скользящая средняя.
        Ema = 2,
        /// Relative Strength Index — индекс относительной силы.
        Rsi = 3,
        /// Moving Average Convergence/Divergence — схождение/расхождение скользящих средних.
        Macd = 4,
        /// Simple Moving Average — простое скользящее среднее.
        Sma = 5,
    }
    impl IndicatorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INDICATOR_TYPE_UNSPECIFIED",
                Self::Bb => "INDICATOR_TYPE_BB",
                Self::Ema => "INDICATOR_TYPE_EMA",
                Self::Rsi => "INDICATOR_TYPE_RSI",
                Self::Macd => "INDICATOR_TYPE_MACD",
                Self::Sma => "INDICATOR_TYPE_SMA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INDICATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INDICATOR_TYPE_BB" => Some(Self::Bb),
                "INDICATOR_TYPE_EMA" => Some(Self::Ema),
                "INDICATOR_TYPE_RSI" => Some(Self::Rsi),
                "INDICATOR_TYPE_MACD" => Some(Self::Macd),
                "INDICATOR_TYPE_SMA" => Some(Self::Sma),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTechAnalysisResponse {
    /// Массив значений результатов технического анализа.
    #[prost(message, repeated, tag = "1")]
    pub technical_indicators: ::prost::alloc::vec::Vec<
        get_tech_analysis_response::TechAnalysisItem,
    >,
}
/// Nested message and enum types in `GetTechAnalysisResponse`.
pub mod get_tech_analysis_response {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TechAnalysisItem {
        /// Временная метка по UTC, для которой были рассчитаны значения индикатора.
        #[prost(message, optional, tag = "1")]
        pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
        /// Значение простого скользящего среднего (средней линии).
        #[prost(message, optional, tag = "2")]
        pub middle_band: ::core::option::Option<super::Quotation>,
        /// Значение верхней линии Боллинджера.
        #[prost(message, optional, tag = "3")]
        pub upper_band: ::core::option::Option<super::Quotation>,
        /// Значение нижней линии Боллинджера.
        #[prost(message, optional, tag = "4")]
        pub lower_band: ::core::option::Option<super::Quotation>,
        /// Значение сигнальной линии.
        #[prost(message, optional, tag = "5")]
        pub signal: ::core::option::Option<super::Quotation>,
        /// Значение линии MACD.
        #[prost(message, optional, tag = "6")]
        pub macd: ::core::option::Option<super::Quotation>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMarketValuesRequest {
    /// Массив идентификаторов инструментов. Принимает значения `figi`, `instrument_uid` или `ticker + '_' + class_code`.
    #[prost(string, repeated, tag = "1")]
    pub instrument_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Массив запрашиваемых параметров.
    #[prost(enumeration = "MarketValueType", repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMarketValuesResponse {
    /// Массив значений параметров.
    #[prost(message, repeated, tag = "1")]
    pub instruments: ::prost::alloc::vec::Vec<MarketValueInstrument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketValueInstrument {
    /// Идентификатор инструмента.
    #[prost(string, tag = "1")]
    pub instrument_uid: ::prost::alloc::string::String,
    /// Массив параметров инструмента.
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<MarketValue>,
    /// Тикер инструмента.
    #[prost(string, tag = "3")]
    pub ticker: ::prost::alloc::string::String,
    /// Класс-код (секция торгов).
    #[prost(string, tag = "4")]
    pub class_code: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MarketValue {
    /// Тип параметра.
    #[prost(enumeration = "MarketValueType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Значение.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Quotation>,
    /// Дата и время.
    #[prost(message, optional, tag = "3")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Тип операции со списком подписок.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscriptionAction {
    /// Статус подписки не определен.
    Unspecified = 0,
    /// Подписаться.
    Subscribe = 1,
    /// Отписаться.
    Unsubscribe = 2,
}
impl SubscriptionAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUBSCRIPTION_ACTION_UNSPECIFIED",
            Self::Subscribe => "SUBSCRIPTION_ACTION_SUBSCRIBE",
            Self::Unsubscribe => "SUBSCRIPTION_ACTION_UNSUBSCRIBE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIPTION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBSCRIPTION_ACTION_SUBSCRIBE" => Some(Self::Subscribe),
            "SUBSCRIPTION_ACTION_UNSUBSCRIBE" => Some(Self::Unsubscribe),
            _ => None,
        }
    }
}
/// Интервал свечи.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscriptionInterval {
    /// Интервал свечи не определен.
    Unspecified = 0,
    /// Минутные свечи.
    OneMinute = 1,
    /// Пятиминутные свечи.
    FiveMinutes = 2,
    /// Пятнадцатиминутные свечи.
    FifteenMinutes = 3,
    /// Часовые свечи.
    OneHour = 4,
    /// Дневные свечи.
    OneDay = 5,
    /// Двухминутные свечи.
    SubscriptionInterval2Min = 6,
    /// Трехминутные свечи.
    SubscriptionInterval3Min = 7,
    /// Десятиминутные свечи.
    SubscriptionInterval10Min = 8,
    /// Тридцатиминутные свечи.
    SubscriptionInterval30Min = 9,
    /// Двухчасовые свечи.
    SubscriptionInterval2Hour = 10,
    /// Четырехчасовые свечи.
    SubscriptionInterval4Hour = 11,
    /// Недельные свечи.
    Week = 12,
    /// Месячные свечи.
    Month = 13,
}
impl SubscriptionInterval {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUBSCRIPTION_INTERVAL_UNSPECIFIED",
            Self::OneMinute => "SUBSCRIPTION_INTERVAL_ONE_MINUTE",
            Self::FiveMinutes => "SUBSCRIPTION_INTERVAL_FIVE_MINUTES",
            Self::FifteenMinutes => "SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES",
            Self::OneHour => "SUBSCRIPTION_INTERVAL_ONE_HOUR",
            Self::OneDay => "SUBSCRIPTION_INTERVAL_ONE_DAY",
            Self::SubscriptionInterval2Min => "SUBSCRIPTION_INTERVAL_2_MIN",
            Self::SubscriptionInterval3Min => "SUBSCRIPTION_INTERVAL_3_MIN",
            Self::SubscriptionInterval10Min => "SUBSCRIPTION_INTERVAL_10_MIN",
            Self::SubscriptionInterval30Min => "SUBSCRIPTION_INTERVAL_30_MIN",
            Self::SubscriptionInterval2Hour => "SUBSCRIPTION_INTERVAL_2_HOUR",
            Self::SubscriptionInterval4Hour => "SUBSCRIPTION_INTERVAL_4_HOUR",
            Self::Week => "SUBSCRIPTION_INTERVAL_WEEK",
            Self::Month => "SUBSCRIPTION_INTERVAL_MONTH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIPTION_INTERVAL_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBSCRIPTION_INTERVAL_ONE_MINUTE" => Some(Self::OneMinute),
            "SUBSCRIPTION_INTERVAL_FIVE_MINUTES" => Some(Self::FiveMinutes),
            "SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES" => Some(Self::FifteenMinutes),
            "SUBSCRIPTION_INTERVAL_ONE_HOUR" => Some(Self::OneHour),
            "SUBSCRIPTION_INTERVAL_ONE_DAY" => Some(Self::OneDay),
            "SUBSCRIPTION_INTERVAL_2_MIN" => Some(Self::SubscriptionInterval2Min),
            "SUBSCRIPTION_INTERVAL_3_MIN" => Some(Self::SubscriptionInterval3Min),
            "SUBSCRIPTION_INTERVAL_10_MIN" => Some(Self::SubscriptionInterval10Min),
            "SUBSCRIPTION_INTERVAL_30_MIN" => Some(Self::SubscriptionInterval30Min),
            "SUBSCRIPTION_INTERVAL_2_HOUR" => Some(Self::SubscriptionInterval2Hour),
            "SUBSCRIPTION_INTERVAL_4_HOUR" => Some(Self::SubscriptionInterval4Hour),
            "SUBSCRIPTION_INTERVAL_WEEK" => Some(Self::Week),
            "SUBSCRIPTION_INTERVAL_MONTH" => Some(Self::Month),
            _ => None,
        }
    }
}
/// Результат подписки.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscriptionStatus {
    /// Статус подписки не определен.
    Unspecified = 0,
    /// Успешно.
    Success = 1,
    /// Инструмент не найден.
    InstrumentNotFound = 2,
    /// Некорректный статус подписки. [Список возможных значений](./marketdata#subscriptionaction).
    SubscriptionActionIsInvalid = 3,
    /// Некорректная глубина стакана. Доступные значения — 1, 10, 20, 30, 40, 50.
    DepthIsInvalid = 4,
    /// Некорректный интервал свечей. [Список возможных значений](./marketdata#subscriptioninterval).
    IntervalIsInvalid = 5,
    /// Превышен лимит на общее количество подписок в рамках стрима. [Лимитная политика](./limits/).
    LimitIsExceeded = 6,
    /// Внутренняя ошибка сервиса.
    InternalError = 7,
    /// Превышен лимит на количество запросов на подписки в течение установленного отрезка времени.
    TooManyRequests = 8,
    /// Активная подписка не найдена. Ошибка может возникнуть только при отписке от несуществующей подписки.
    SubscriptionNotFound = 9,
    /// Указан некорректный источник.
    SourceIsInvalid = 10,
}
impl SubscriptionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUBSCRIPTION_STATUS_UNSPECIFIED",
            Self::Success => "SUBSCRIPTION_STATUS_SUCCESS",
            Self::InstrumentNotFound => "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND",
            Self::SubscriptionActionIsInvalid => {
                "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID"
            }
            Self::DepthIsInvalid => "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID",
            Self::IntervalIsInvalid => "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID",
            Self::LimitIsExceeded => "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED",
            Self::InternalError => "SUBSCRIPTION_STATUS_INTERNAL_ERROR",
            Self::TooManyRequests => "SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS",
            Self::SubscriptionNotFound => "SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND",
            Self::SourceIsInvalid => "SUBSCRIPTION_STATUS_SOURCE_IS_INVALID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIPTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBSCRIPTION_STATUS_SUCCESS" => Some(Self::Success),
            "SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND" => Some(Self::InstrumentNotFound),
            "SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID" => {
                Some(Self::SubscriptionActionIsInvalid)
            }
            "SUBSCRIPTION_STATUS_DEPTH_IS_INVALID" => Some(Self::DepthIsInvalid),
            "SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID" => Some(Self::IntervalIsInvalid),
            "SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED" => Some(Self::LimitIsExceeded),
            "SUBSCRIPTION_STATUS_INTERNAL_ERROR" => Some(Self::InternalError),
            "SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS" => Some(Self::TooManyRequests),
            "SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND" => {
                Some(Self::SubscriptionNotFound)
            }
            "SUBSCRIPTION_STATUS_SOURCE_IS_INVALID" => Some(Self::SourceIsInvalid),
            _ => None,
        }
    }
}
/// Типы источников сделок.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TradeSourceType {
    /// Тип источника сделки не определён.
    TradeSourceUnspecified = 0,
    /// Биржевые сделки.
    TradeSourceExchange = 1,
    /// Сделки дилера.
    TradeSourceDealer = 2,
    /// Все сделки.
    TradeSourceAll = 3,
}
impl TradeSourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TradeSourceUnspecified => "TRADE_SOURCE_UNSPECIFIED",
            Self::TradeSourceExchange => "TRADE_SOURCE_EXCHANGE",
            Self::TradeSourceDealer => "TRADE_SOURCE_DEALER",
            Self::TradeSourceAll => "TRADE_SOURCE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRADE_SOURCE_UNSPECIFIED" => Some(Self::TradeSourceUnspecified),
            "TRADE_SOURCE_EXCHANGE" => Some(Self::TradeSourceExchange),
            "TRADE_SOURCE_DEALER" => Some(Self::TradeSourceDealer),
            "TRADE_SOURCE_ALL" => Some(Self::TradeSourceAll),
            _ => None,
        }
    }
}
/// Направление сделки.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TradeDirection {
    /// Направление сделки не определено.
    Unspecified = 0,
    /// Покупка.
    Buy = 1,
    /// Продажа.
    Sell = 2,
}
impl TradeDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRADE_DIRECTION_UNSPECIFIED",
            Self::Buy => "TRADE_DIRECTION_BUY",
            Self::Sell => "TRADE_DIRECTION_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRADE_DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "TRADE_DIRECTION_BUY" => Some(Self::Buy),
            "TRADE_DIRECTION_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
/// Интервал свечей. Максимальное значение интервала приведено ориентировочно, может отличаться в большую сторону в зависимости от параметров запроса.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CandleInterval {
    /// Интервал не определен.
    Unspecified = 0,
    /// От 1 минуты до 1 дня. Максимальное значение `limit` — 2400.
    CandleInterval1Min = 1,
    /// От 5 минут до недели. Максимальное значение `limit` — 2400.
    CandleInterval5Min = 2,
    /// От 15 минут до 3 недель. Максимальное значение `limit` — 2400.
    CandleInterval15Min = 3,
    /// От 1 часа до 3 месяцев. Максимальное значение `limit` — 2400.
    Hour = 4,
    /// От 1 дня до 6 лет. Максимальное значение `limit` — 2400.
    Day = 5,
    /// От 2 минут до 1 дня. Максимальное значение `limit` — 1200.
    CandleInterval2Min = 6,
    /// От 3 минут до 1 дня. Максимальное значение `limit` — 750.
    CandleInterval3Min = 7,
    /// От 10 минут до недели. Максимальное значение `limit` — 1200.
    CandleInterval10Min = 8,
    /// От 30 минут до 3 недель. Максимальное значение `limit` — 1200.
    CandleInterval30Min = 9,
    /// От 2 часов до 3 месяцев. Максимальное значение `limit` — 2400.
    CandleInterval2Hour = 10,
    /// От 4 часов до 3 месяцев. Максимальное значение `limit` — 700.
    CandleInterval4Hour = 11,
    /// От 1 недели до 5 лет. Максимальное значение `limit` — 300.
    Week = 12,
    /// От 1 месяца до 10 лет. Максимальное значение `limit` — 120.
    Month = 13,
    /// От 5 секунд до 200 минут. Максимальное значение `limit` — 2500.
    CandleInterval5Sec = 14,
    /// От 10 секунд до 200 минут. Максимальное значение `limit` — 1250.
    CandleInterval10Sec = 15,
    /// От 30 секунд до 20 часов. Максимальное значение `limit` — 2500.
    CandleInterval30Sec = 16,
}
impl CandleInterval {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CANDLE_INTERVAL_UNSPECIFIED",
            Self::CandleInterval1Min => "CANDLE_INTERVAL_1_MIN",
            Self::CandleInterval5Min => "CANDLE_INTERVAL_5_MIN",
            Self::CandleInterval15Min => "CANDLE_INTERVAL_15_MIN",
            Self::Hour => "CANDLE_INTERVAL_HOUR",
            Self::Day => "CANDLE_INTERVAL_DAY",
            Self::CandleInterval2Min => "CANDLE_INTERVAL_2_MIN",
            Self::CandleInterval3Min => "CANDLE_INTERVAL_3_MIN",
            Self::CandleInterval10Min => "CANDLE_INTERVAL_10_MIN",
            Self::CandleInterval30Min => "CANDLE_INTERVAL_30_MIN",
            Self::CandleInterval2Hour => "CANDLE_INTERVAL_2_HOUR",
            Self::CandleInterval4Hour => "CANDLE_INTERVAL_4_HOUR",
            Self::Week => "CANDLE_INTERVAL_WEEK",
            Self::Month => "CANDLE_INTERVAL_MONTH",
            Self::CandleInterval5Sec => "CANDLE_INTERVAL_5_SEC",
            Self::CandleInterval10Sec => "CANDLE_INTERVAL_10_SEC",
            Self::CandleInterval30Sec => "CANDLE_INTERVAL_30_SEC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CANDLE_INTERVAL_UNSPECIFIED" => Some(Self::Unspecified),
            "CANDLE_INTERVAL_1_MIN" => Some(Self::CandleInterval1Min),
            "CANDLE_INTERVAL_5_MIN" => Some(Self::CandleInterval5Min),
            "CANDLE_INTERVAL_15_MIN" => Some(Self::CandleInterval15Min),
            "CANDLE_INTERVAL_HOUR" => Some(Self::Hour),
            "CANDLE_INTERVAL_DAY" => Some(Self::Day),
            "CANDLE_INTERVAL_2_MIN" => Some(Self::CandleInterval2Min),
            "CANDLE_INTERVAL_3_MIN" => Some(Self::CandleInterval3Min),
            "CANDLE_INTERVAL_10_MIN" => Some(Self::CandleInterval10Min),
            "CANDLE_INTERVAL_30_MIN" => Some(Self::CandleInterval30Min),
            "CANDLE_INTERVAL_2_HOUR" => Some(Self::CandleInterval2Hour),
            "CANDLE_INTERVAL_4_HOUR" => Some(Self::CandleInterval4Hour),
            "CANDLE_INTERVAL_WEEK" => Some(Self::Week),
            "CANDLE_INTERVAL_MONTH" => Some(Self::Month),
            "CANDLE_INTERVAL_5_SEC" => Some(Self::CandleInterval5Sec),
            "CANDLE_INTERVAL_10_SEC" => Some(Self::CandleInterval10Sec),
            "CANDLE_INTERVAL_30_SEC" => Some(Self::CandleInterval30Sec),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CandleSource {
    /// Источник свечей не определен.
    Unspecified = 0,
    /// Биржевые свечи.
    Exchange = 1,
    /// Свечи  дилера в результате торговли по выходным.
    DealerWeekend = 2,
}
impl CandleSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CANDLE_SOURCE_UNSPECIFIED",
            Self::Exchange => "CANDLE_SOURCE_EXCHANGE",
            Self::DealerWeekend => "CANDLE_SOURCE_DEALER_WEEKEND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CANDLE_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "CANDLE_SOURCE_EXCHANGE" => Some(Self::Exchange),
            "CANDLE_SOURCE_DEALER_WEEKEND" => Some(Self::DealerWeekend),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MarketValueType {
    /// Не определен.
    InstrumentValueUnspecified = 0,
    /// Последняя биржевая цена.
    InstrumentValueLastPrice = 1,
    /// Последняя цена дилера.
    InstrumentValueLastPriceDealer = 2,
    /// Цена закрытия.
    InstrumentValueClosePrice = 3,
    /// Цена последней сделки с вечерней сессии.
    InstrumentValueEveningSessionPrice = 4,
    /// Открытый интерес, возвращается только для фьючерсов.
    InstrumentValueOpenInterest = 5,
    /// Теоретическая цена, возвращается только для опционов.
    InstrumentValueTheorPrice = 6,
    /// Доходность
    InstrumentValueYield = 7,
}
impl MarketValueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InstrumentValueUnspecified => "INSTRUMENT_VALUE_UNSPECIFIED",
            Self::InstrumentValueLastPrice => "INSTRUMENT_VALUE_LAST_PRICE",
            Self::InstrumentValueLastPriceDealer => "INSTRUMENT_VALUE_LAST_PRICE_DEALER",
            Self::InstrumentValueClosePrice => "INSTRUMENT_VALUE_CLOSE_PRICE",
            Self::InstrumentValueEveningSessionPrice => {
                "INSTRUMENT_VALUE_EVENING_SESSION_PRICE"
            }
            Self::InstrumentValueOpenInterest => "INSTRUMENT_VALUE_OPEN_INTEREST",
            Self::InstrumentValueTheorPrice => "INSTRUMENT_VALUE_THEOR_PRICE",
            Self::InstrumentValueYield => "INSTRUMENT_VALUE_YIELD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_VALUE_UNSPECIFIED" => Some(Self::InstrumentValueUnspecified),
            "INSTRUMENT_VALUE_LAST_PRICE" => Some(Self::InstrumentValueLastPrice),
            "INSTRUMENT_VALUE_LAST_PRICE_DEALER" => {
                Some(Self::InstrumentValueLastPriceDealer)
            }
            "INSTRUMENT_VALUE_CLOSE_PRICE" => Some(Self::InstrumentValueClosePrice),
            "INSTRUMENT_VALUE_EVENING_SESSION_PRICE" => {
                Some(Self::InstrumentValueEveningSessionPrice)
            }
            "INSTRUMENT_VALUE_OPEN_INTEREST" => Some(Self::InstrumentValueOpenInterest),
            "INSTRUMENT_VALUE_THEOR_PRICE" => Some(Self::InstrumentValueTheorPrice),
            "INSTRUMENT_VALUE_YIELD" => Some(Self::InstrumentValueYield),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderBookType {
    /// Не определен.
    OrderbookTypeUnspecified = 0,
    /// Биржевой стакан.
    OrderbookTypeExchange = 1,
    /// Стакан дилера.
    OrderbookTypeDealer = 2,
    /// Стакан биржевой и дилера.
    OrderbookTypeAll = 3,
}
impl OrderBookType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OrderbookTypeUnspecified => "ORDERBOOK_TYPE_UNSPECIFIED",
            Self::OrderbookTypeExchange => "ORDERBOOK_TYPE_EXCHANGE",
            Self::OrderbookTypeDealer => "ORDERBOOK_TYPE_DEALER",
            Self::OrderbookTypeAll => "ORDERBOOK_TYPE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDERBOOK_TYPE_UNSPECIFIED" => Some(Self::OrderbookTypeUnspecified),
            "ORDERBOOK_TYPE_EXCHANGE" => Some(Self::OrderbookTypeExchange),
            "ORDERBOOK_TYPE_DEALER" => Some(Self::OrderbookTypeDealer),
            "ORDERBOOK_TYPE_ALL" => Some(Self::OrderbookTypeAll),
            _ => None,
        }
    }
}
/// Тип последней цены
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LastPriceType {
    /// Не определен.
    LastPriceUnspecified = 0,
    /// Цена биржи.
    LastPriceExchange = 1,
    /// Цена дилера
    LastPriceDealer = 2,
}
impl LastPriceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LastPriceUnspecified => "LAST_PRICE_UNSPECIFIED",
            Self::LastPriceExchange => "LAST_PRICE_EXCHANGE",
            Self::LastPriceDealer => "LAST_PRICE_DEALER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LAST_PRICE_UNSPECIFIED" => Some(Self::LastPriceUnspecified),
            "LAST_PRICE_EXCHANGE" => Some(Self::LastPriceExchange),
            "LAST_PRICE_DEALER" => Some(Self::LastPriceDealer),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod market_data_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MarketDataServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MarketDataServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MarketDataServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MarketDataServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MarketDataServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// GetCandles — исторические свечи по инструменту
        pub async fn get_candles(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCandlesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCandlesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetCandles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetCandles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetLastPrices — цены последних сделок по инструментам
        pub async fn get_last_prices(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLastPricesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLastPricesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastPrices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetLastPrices",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetOrderBook — стакан по инструменту
        pub async fn get_order_book(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrderBookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetOrderBookResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetOrderBook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetOrderBook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetTradingStatus — статус торгов по инструменту
        pub async fn get_trading_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTradingStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTradingStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetTradingStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetTradingStatuses — статус торгов по инструментам
        pub async fn get_trading_statuses(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTradingStatusesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTradingStatusesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatuses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetTradingStatuses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetLastTrades — обезличенные сделки
        /// Обезличенные сделки по инструменту. Метод гарантирует получение информации за последний час.
        pub async fn get_last_trades(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLastTradesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLastTradesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastTrades",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetLastTrades",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetClosePrices — цены закрытия торговой сессии по инструментам
        pub async fn get_close_prices(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClosePricesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetClosePricesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetClosePrices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetClosePrices",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetTechAnalysis — технические индикаторы по инструменту
        pub async fn get_tech_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTechAnalysisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTechAnalysisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetTechAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetTechAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetMarketValues — рыночные данные по инструментам
        pub async fn get_market_values(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMarketValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMarketValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetMarketValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataService",
                        "GetMarketValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod market_data_stream_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MarketDataStreamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MarketDataStreamServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MarketDataStreamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MarketDataStreamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MarketDataStreamServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// MarketDataStream — bidirectional стрим предоставления биржевой информации
        pub async fn market_data_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::MarketDataRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MarketDataResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataStreamService/MarketDataStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataStreamService",
                        "MarketDataStream",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// MarketDataServerSideStream — server-side стрим предоставления биржевой информации
        pub async fn market_data_server_side_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::MarketDataServerSideStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MarketDataResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tinkoff.public.invest.api.contract.v1.MarketDataStreamService/MarketDataServerSideStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tinkoff.public.invest.api.contract.v1.MarketDataStreamService",
                        "MarketDataServerSideStream",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
